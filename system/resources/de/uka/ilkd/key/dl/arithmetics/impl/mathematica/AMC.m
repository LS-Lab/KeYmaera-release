(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["AMC`"];


(* implicit global parameter *)
$SymbolicName::usage="The function $SymbolicName[n] is supposed to return a sufficiently fresh name for a symbol possibly with number n.";


Vocabulary::usage="Vocabulary[e] gives the list of all atomic symbols occurring in e, except built-ins and numbers.";Atomize::usage="Atomize[list] makes all elements of list atomic. That is, it returns {atomizer,deatomizer} where atomizer is a list of rules that replace the elements of list by new unique atomic symbols, and deatomizer undoes the same renaming.";


InEqualify::usage="Turns the given equation or inequations into equivalent \[GreaterEqual]-inequations or >-inequations";
InEqualifyNormalize::usage="Equivalently normalises given equations into equivalent form t\[GreaterEqual]0 or t>0.";


IFindInstance::usage="IFindInstance[expr] finds a real instance satisfying expr with respect to all free Vocabulary[expr] using FindInstance.
IFindInstance[expr,dom,n] finds n instances over domain";


DifferentialSymbols::usage = "Extracts all variables x from an expression that occur in the form x' or x'[t]";


SymbolicInitialValues::usage="Make a list of equations x[0]==x0 for all differential variables that occur in eqn.";
IDSolve::usage="IDSolve[eqn,x] is an improved version of DSolve that solves the symbolic initial value problem belonging to an ordinary differential equation set eqn with independent variable x.";


ParityDecomposition::usage="ParityDecomposition[expr] Performs parity decomposition of a given polynomial."


PO::usage="PO[expr] Fetches facotrs of odd multiplicity from the parity decomposition."


PE::usage="PE[expr] Fetches facotrs of even multiplicity from the parity decomposition."


ZeroRHS::usage="ZeroRHS[expr] turns a quantifier-free formula into one where the right hand side is zero."


AtomicParityNF::usage="AtomicParityNF[expr] turns a quantifier-free atomic formula into one where each atom is square-free.";


ParityNF::usage="ParityNF[expr] turns a quantifier-free formula into one where each atom is square-free."


IsClosedSquareFreeAtom::usage="IsClosedSquareFreeAtom[expr] returns True if the term is definedable by a square-free polynomial"


GetBoundary::usage="GetBoundary[expr] Computes the boundary of a closed semi-algebraic set."


NonZeroGrad::usage="NonZeroGrad[expr,statevars] Computes condition ensuring that the gradient vector is non-zero at the boundary."


IsConjunct::usage="IsConjunct[expr] Returns True if the expression is a conjunctive formula."


GeqToLeq::usage="GeqToLeq[expr] Converts GreaterThan atoms into LessThan by swapping arguments and then setting the rhs to zero."


IsListOfLeq::usage="IsListOfLeq[expr] Returns True if the expression is a List of atoms with LessEqual as their predicate symbol, returns False otherwise."


ToLessEqualConjunct::usage="ToLessEqualConjunct[expr] Converts the expression into a conjunction of LessEqual atoms, if such a transformation is possible; otherwise, the original expression is returned."


IsLessEqualConjunct::usage="IsLessEqualConjunct[expr] Returns True if the expression into a conjunction of LessEqual atoms; returns False otherwise."


Lf::usage="Checks for membership of the vector field inside the contingent cone of a set given by Min[Max[g1,...,gn]...]."


VCGen::usage="Generates verification conditions for non-smooth barrier certificates of the form Min[Max[g1,...,gn]...]."


IDiffInd::usage ="IDiffInd[e] transforms given real arithmetic formula e to a differential inductive invariant sustaining e. The total differential Dt will be formed.
IDiffInd[e,ODE] does the same and instantiates the derivatives in the result using the differential equations in the differential equation system ODE, in which differential equations are x'==2x+y.";
IDiffFin::usage ="IDiffFin[e,\[Epsilon]] transforms given real arithmetic formula e to a differential inductive variant attaining e with progress \[Epsilon]. The total differential Dt will be formed.
IDiffFin[e,\[Epsilon],ODE] does the same and instantiates the derivatives in the result using the differential equations in the differential equation system ODE, in which differential equations are x'==2x+y.";
DiffInd::usage ="DiffInd[e,t] transforms given real arithmetic formula e to a differential inductive invariant sustaining it. The differential will be formed with respect to d/dt.
DiffInd[e,t,ODE] does the same and instantiates the derivatives in the result using the differential equations in the differential equation system ODE, in which differential equations are x'[t]==2x[t]+y.";


Sprocedure::usage="SprocedureFormula[a,e] uses the S-procedure trick to transform a\[Implies]e into a single equation with additional existential variables. Both assumptions a and conclusion e are assumed to be purely conjunctively.";SprocedureFormula::usage="SprocedureFormula[a,e] uses the S-procedure trick to transform a\[Implies]e into a single equation with additional existential variables. Both assumptions a and conclusion e are assumed to be purely conjunctively. Unlike Sprocedure, this helper only returns the unquantified kernel.";


FormalPolynomial::usage="FormalPolynomial[{{x,3},{y,2}}] gives {p,l} where p is a formal polynomial with all monomials \[Lambda]*x^i*y^j with i<=3 and j<=2 and \[Lambda] being a parameter from the list l. Likewise for larger sets with more variables.
Adding an integer parameter n specifies that the total degree of each monomial is <=n. Adding parameter {n} specifies that the polynomial is to be homogeneous of total degree =n for each monomial.
FormalPolynomial[{x,y,z},3] is a shorthand for a formal polynomial of total degree 3 in variables x,y,z (each, consequently with degree <=3). A formal polynomial of degree d in n variables has Binomial[n+d,d] parameters.";


Transition::usage="Transition[action][State][t]
    is the state reachable by performing the given action from initial state State after duration t.
@see Actions include
 - evolve[ODE] yields a continuous transition along differential equation ODE with current state as IVP.
 - guard[X]
 - set[x1->x2-x3] discrete assignment to State.
 - transform[X] discrete transition X.
 - act1\[CirclePlus]act2\[CirclePlus]act3 nondeterministically choose between acti.
 - {act1,act2,act3} sequentially performs the given list of actions. Switching between the actions occurs
    - instantly for discrete actions
    - non-deterministically at first occurrence of subsequent guard for evolve.
    Inductively performs
    Transition[act2][(Transition[act1][State][switchtime1])][t-switchtime1]
@param $numericalODE implicit global parameter determining whether to use symbolic (False) or numerical tools (True) for solving IVPs.
@param $TimeHorizon implicit global parameter determining time bound for solving ODEs.
@param $verify implicit global parameter determining whether to verify symbolic solutions of ODEs.
@see SComp[(Transition[action][State])[t]]";

(* implicit global parameters for Transition *)
$Transition::usage="The function $Transition[action][State][tp] can be defined to have additional user-defined actions available for use in Transition.";
$numericalODE::usage="implicit global parameter determining whether to use symbolic (False) or numerical tools (True) for solving IVPs.";
$TimeHorizon::usage="implicit global parameter determining time bound for solving ODEs.";
$verify::usage="implicit global parameter determining whether to verify symbolic solutions of ODEs.";

$TransFailed::usage = "Special symbol that denotes the result of a failed transition (due to failed guard conditions).";
$Unknown::usage = "Special symbol that denotes an unkown state that is reached, e.g., after performing a discrete transition longer than 0 seconds.";


evolve::usage="Transition action evolve[ODE] yields a continuous transition along differential equation system ODE with the current state as IVP.
   The differential equations in ODE must be formulated with variables with the precise names x1, x2, x3, and so on in Global context. And these ODE must depend on the variable with the precise name t like in {x1'[t]==5}";
test::usage = "Transition action test[x2>x1-2] tests whether the given condition is satisfied for the respective state components xi as a shortcut for guard.";
guard::usage = "Transition action guard[X] tests whether condition X is satisfied for the current state. Nothing happens if condition X is true but further evolution is blocked if X is false.";
set::usage = "Transition action set[x2->x1-x3+1] performs a discrete assignment to the respective state components xi. Likewise, lists of updates like set[{x2->x1-x3+1,x1->5}]can be handled with simultaneous effect. As a shortcut for transform. As a deprecated notation, assignments can be used as in set[x1=x3+1], which is discouraged.";
transform::usage="Transition action transform[X] yields a discrete transition. It performs the discrete jump or projection by applying the given transformation X to the state.";
CirclePlus::usage = "Transition action act1\[CirclePlus]act2\[CirclePlus]act3 nondeterministically choose between the respective actions acti.";
 (*List::usage = "Transition action {act1,act2,act3} sequentially performs the given list of actions. Switching between the actions occurs
    - instantly for discrete actions
    - non-deterministically at first occurrence of subsequent guard for evolve.
    Inductively performs
    Transition[act2][(Transition[act1][State][switchtime1])][t-switchtime1]"; *)


UpdateMerge::usage="UpdateMerge[U1,U2] gives the merged update with U1 applied to U2, i.e., U2 after U1";


SComp::usage = "unpacks the state components (originating from a Transition[...][...][...])";


AMC::usage="Refinement-based approximate bounded model checking
with time-horizon TimeHorizon and minimum grid-size fraction cutoff.
   @param dynamics an operational model whose generated transition system describes the system dynamics.
   @param initialRange range of intervals {Interval[{0,2\[Pi]}],Interval[{0,10}]} that is possibly used for initial states.
   @param criticality is a function to determine the criticality of states, i.e., the remaining safety distance (an estimate for the distance to the border of the bad states). The usual meaning is that states with criticality>0 are safe, whereas states with criticality<0 are unsafe. But this is not enforced by AMC. However, minimum criticality values are returned preferably, that is, most dangerous and critical.
    Returns {\[Infinity],{}} when unreachable.
    Returns {c,{cex}} when cex is a reachable (counter)example with criticality c=criticality[cex], which seems minimal among all counterexamples, that is, most critical.";
AMCphase::usage="Model checking on \[Delta]-grid with time-horizon TimeHorizon.
   @return Returns {\[Infinity],{}} when unreachable. Returns {c,cex} otherwise, where c is criticality[cex] of the counterexample";


Options[PlotTrace]=Join[{TimeHorizon:>$TimeHorizon,PlotState->Automatic,Animate->True,AnimationRunning->False,AspectRatio->Automatic},
Options[ParametricPlot],Options[Animate],Options[Graphics]
];


PlotTrace::usage="PlotTrace[a,x0,coords] plots and animates full dynamics of transistion system with actions a starting in state x0 with given coordinates displayed.";
PlotState::usage="Option for PlotTrace specifying the function used for plotting a state configuration.";
Animate::usage="Option for PlotTrace specifying whether animations should be produced or only traces.";


Options[IFindTransition]={TimeHorizon:>$TimeHorizon,Sampling->100,Instances->20}


IFindTransition::usage="IFindTransition[prestate,eqns,t,inv,goal] quickly tries to check if there is a transition from given prestate along the differential equations eqns to a state satisfying goal, without ever leaving inv in between.
IFindTransition[initial,update,eqns,t,inv,goal] quickly tries to check if there is a transition along update;eqns&inv from a state satisfying the formula initial to a state satisfying goal";


Begin["`Private`"]


(* Compute parity decomposition of a given polynomial *)
ParityDecomposition[p_?PolynomialQ]:=Module[
{
pOdd=Apply[Times,
Map[Function[x, If[OddQ[Part[x,2]],Part[x,1],1]],
FactorSquareFreeList[p]]],

pEven=Apply[Times,
Map[Function[x, If[EvenQ[Part[x,2]],Part[x,1],1]],
FactorSquareFreeList[p]]]
},
List[pOdd,pEven]
]


(* Convenience functions *)
PO[q_?PolynomialQ]:=Module[{},ParityDecomposition[q][[1]]]


PE[q_?PolynomialQ]:=Module[{},ParityDecomposition[q][[2]]]


(* Set righ-hand side of terms to zero *)
ZeroRHS[atom_] := Module[{},atom/.{
Equal[a_,b_] :>  Equal[a-b,0],
Unequal[a_,b_] :>  Unequal[a-b,0],
Greater[a_,b_] :>  Greater[a-b,0],
GreaterEqual[a_,b_] :>  GreaterEqual[a-b,0],
Less[a_,b_] :> Less[a-b,0], 
LessEqual[a_,b_] :>  LessEqual[a-b,0]
}]


(* Dolzmann equivalences for polynomial atoms *)
AtomicParityNF[atom_]:=Module[{},ZeroRHS[atom]/.{
Equal[p_?PolynomialQ,0] :>  Equal[PO[p]*PE[p],0],
Unequal[p_,0] :>  And[Unequal[PO[p],0],Unequal[PE[p],0]],
Greater[p_,0] :>  And[Greater[PO[p],0],Unequal[PE[p],0]],
GreaterEqual[p_,0]  :> Or[GreaterEqual[PO[p],0],Equal[PE[p],0]],
Less[p_,0] :>  And[Less[PO[p],0],Unequal[PE[p],0]],
LessEqual[p_,0] :>  Or[LessEqual[PO[p],0],Equal[PE[p],0]]
}]


(* Dolzmann equivalences for arbitrary formulas *)
ParityNF[formula_]:=Module[{},formula/.{
And[a_,b_] :>  And[ParityNF[a],ParityNF[b]],
Or[a_,b_] :>  Or[ParityNF[a],ParityNF[b]],
Implies[a_,b_] :>  Implies[ParityNF[a],ParityNF[b]],
Equivalent[a_,b_] :>  Equivalent[ParityNF[a],ParityNF[b]],
Not[a_] :>  Not[ParityNF[a]],
x_ :> AtomicParityNF[x]
}]


IsClosedSquareFreeAtom[formula_]:=Module[{},
ParityNF[formula]/.{
eq_Equal:> True,
leq_LessEqual:> True,
geq_GreaterEqual:> True,
x_ :> False}
]


GetBoundary[formula_]:=Module[{sfatom=ParityNF[formula]},
If[IsClosedSquareFreeAtom[sfatom],Apply[Equal,sfatom],formula]
]


NonZeroGrad[formula_,statevars_]:=Module[{},
GetBoundary[formula]/.{
Equal[lhs_,rhs_]:> Unequal[Apply[Plus,Map[Function[x,x^2],Grad[lhs,statevars]]],0],
else_ :> False
}
]


IsConjunct[form_]:=Module[{},
LogicalExpand[form]/.{
a_And :> True,
else_ :> False} ]


GeqToLeq[atom_]:=Module[{},
atom/.{GreaterEqual[lhs_,rhs_] :> ZeroRHS[LessEqual[rhs,lhs]]}
] 


IsListOfLeq[list_]:=Module[{},
If[MatchQ[list,_List],
Apply[And,Map[Function[x,MatchQ[x,_LessEqual]],list]],
False]]


ToLessEqualConjunct[formula_]:=Module[{
squareFreeDNF = LogicalExpand[ParityNF[formula]],
},
If[IsConjunct[squareFreeDNF],
If[IsListOfLeq[Map[GeqToLeq,Apply[List, squareFreeDNF]]],
Map[GeqToLeq,squareFreeDNF],
formula],formula]
]


IsLessEqualConjunct[formula_]:=Module[{},
If[IsConjunct[formula],
If[IsListOfLeq[Apply[List, formula]],
True,
False],False]
]


(* Differentiable case *)
Lf[p_, f_List, vars_List]:=Grad[p,vars].f<0


(* Conjunctive case - max functions *)
Lf[max[p_], f_List, vars_List]:=Lf[p,f,vars]

Lf[max[p1_,pn__], f_List, vars_List]:=And[
Implies[p1>max[pn],Lf[p1,f,vars]],
Implies[max[pn]>p1,Lf[max[pn],f,vars]],
Implies[p1==max[pn],And[Lf[p1,f,vars],Lf[max[pn],f,vars]]]
]


(* Disjunctive case - min functions *)
Lf[min[p_], f_List, vars_List]:=Lf[p,f,vars]

Lf[min[p1_,pn__], f_List, vars_List]:=And[
Implies[p1<min[pn],Lf[p1,f,vars]],
Implies[min[pn]<p1,Lf[min[pn],f,vars]],
Implies[p1==min[pn],Or[Lf[p1,f,vars],Lf[min[pn],f,vars]]]
]


toMinMaxForm[formula_]:=Module[{},
ZeroRHS[LogicalExpand[formula]/.{GreaterEqual[a_,b_]:> LessEqual[b,a]}]/.{And :> max, Or:>  min}/.{LessEqual[a_,0]:> a}]


VCGen[formula_, chi_, f_List,vars_List]:=Module[{
rightform=FreeQ[formula,Equal]&&FreeQ[formula,Greater]&&FreeQ[formula,Less]&&FreeQ[formula,Unequal],
minmax=toMinMaxForm[formula]},
If[rightform,
Reduce[Implies[chi && minmax==0/.{max :>Max, min:> Min},Lf[minmax,f,vars]/.{max :> Max, min:> Min}],vars,Reals],
False]
]


Options[Vocabulary]={};
Vocabulary[expr_,options___] := Union[Cases[expr,(x_Symbol :> x /; AtomQ[x] \[And]\[Not]NumberQ[x]\[And]\[Not]MemberQ[Attributes[x],Protected]),{0,\[Infinity]},
Join[{options},Options[Vocabulary]]]]
(* official solution: Module[{cond=Not[MemberQ[Attributes[#],Protected]]&},Union[Cases[expr,_Symbol?cond[_]|_Symbol?cond,\[Infinity]]]] *)
SetAttributes[Vocabulary,{Protected,ReadProtected,Locked}]


Atomize[list_List] :=Module[{atomizer,deatomizer},
deatomizer=Map[Function[t,
Unique["$atomized$",Temporary]->t
],list];
atomizer=Cases[deatomizer,dar:(atom_->term_) ->(term->atom)];
{atomizer,deatomizer}]
SetAttributes[Atomize,{Protected,ReadProtected,Locked}]



InEqualify[e1_>=e2_] := e1>=e2
InEqualify[e1_==e2_] := e1>=e2 \[And] e2>=e1
InEqualify[e1_<=e2_] := e2>=e1
InEqualify[e1_>e2_] := e1>e2
InEqualify[e1_!=e2_] := Message[InEqualify::form,"unsupported inequation",e1!=e2]
InEqualify[e1_<e2_] := e2>e1
InEqualify[e_And] := Flatten[Map[InEqualify,Flatten[e,1,And]]]
InEqualify[e_Or] := Flatten[Map[InEqualify,Flatten[e,1,Or]]]


InEqualifyNormalize[e1_>=e2_] := e1-e2>=0
InEqualifyNormalize[e1_==e2_] := e1-e2>=0 \[And] e2-e1>=0
InEqualifyNormalize[e1_<=e2_] := e2-e1>=0
InEqualifyNormalize[e1_>e2_] := e1-e2>0
InEqualifyNormalize[e1_!=e2_] := Message[InEqualify::form,"unsupported inequation",e1!=e2]
InEqualifyNormalize[e1_<e2_] := e2-e1>0
InEqualifyNormalize[e_And] := Flatten[Map[InEqualifyNormalize,Flatten[e,1,And]]]
InEqualifyNormalize[e_Or] := Flatten[Map[InEqualifyNormalize,Flatten[e,1,Or]]]


InEqualify::form="Unexpected form `1` in `2`.";


IFindInstance[False]:={}
IFindInstance[expr_] := FindInstance[expr,Vocabulary[expr],Reals]
IFindInstance[False,dom_,n_]:={}
IFindInstance[expr_,dom_,n_] := FindInstance[expr,Vocabulary[expr],dom,n]


SetAttributes[{InEqualify,InEqualifyNormalize,FindInstance,IFindInstance},{Protected,ReadProtected,Locked}]


DifferentialSymbols[expr_]:=Cases[expr,(Derivative[n_][x_][t_]|Derivative[n_][x_]):>x,{0,\[Infinity]}]


SymbolicInitialValues[eqn_,initial_:0,suffix_:ToString[initial]] := Map[Function[x,x[initial]==Symbol[ToString[x]<>suffix]],DifferentialSymbols[eqn]]


(*IDSolve[eqn_,x_] :=Module[{depvars,symbolicinitialvalues,atomize,deatomize},
depvars=DifferentialSymbols[eqn];
(* add some symbolic name for x[0] and replace this name back to x[0] in the result *)
{atomize,deatomize}=Atomize[Map[#[0]&,depvars]];
ymbolicinitialvalues=ReplaceAll[atomize,Rule->Equal];
DSolve[Join[eqn,symbolicinitialvalues],
Map[#[x]&,depvars],
x] /. deatomize
]*)


IDSolve[eqn_,x_] :=Module[{depvars,initialreductionrules,symbolicinitialvalues},
depvars=DifferentialSymbols[eqn];
(* add some symbolic name for x[0] and replace this name back to x[0] in the result *)
initialreductionrules=Map[Unique[ToString[#]<>"$init$",Temporary]->#[0]&,depvars];
symbolicinitialvalues=Cases[initialreductionrules,irr:(ivn_->iv_[0]) ->(iv[0]==ivn)];
DSolve[Join[eqn,symbolicinitialvalues],
Map[#[x]&,depvars],
x] /. initialreductionrules
]


SetAttributes[{SymbolicInitialValues,DifferentialSymbols,IDSolve},{Protected,ReadProtected,Locked}]


DiffInd[e_,t_] :=
 Module[{fml},
fml = LogicalExpand[e];
If[FreeQ[fml,_Not|_ForAll|_Some],
(* during differential induction, all literals need to be sustained differentially, hence replace \[Or] by \[And] right away *)
(fml = fml /.Or->And;
If[FreeQ[fml,Not[_]|_Or],
(fml/.
(* weaken > to >= and < to <= during DiffInd *)
{eq_Greater :>GreaterEqual@@eq,eq_Less :>LessEqual@@eq})
/. (* map D over left and right part of (in)equalities *){eq_Equal|eq_GreaterEqual|eq_LessEqual|eq_Greater|eq_Less :>Map[D[#,t]&,eq],
eq_Unequal :> (Message[DiffInd::illegal,eq]; $Failed)
},
(* Or not yet implemented. Not is rejected *)
(Message[DiffInd::illegal,fml];$Failed)
]),
(* Or not yet implemented. Not is rejected *)
(Message[DiffInd::illegal,fml];$Failed)
]
]
DiffInd[e_,t_,ODE_]:= (DiffInd[e,t]/.Flatten[Map[ToRules,ODE]])


IDiffInd[e_] :=
 Module[{fml},
fml = LogicalExpand[e] ;
If[FreeQ[fml,_Not|_ForAll|_Some],
(* during differential induction, all literals need to be sustained differentially, hence replace \[Or] by \[And] right away *)
(fml=fml/.Or->And;
If[FreeQ[fml,Not[_]|_Or],
(fml/.
(* weaken > to >= and < to <= during DiffInd *)
{eq_Greater :>GreaterEqual@@eq,eq_Less :>LessEqual@@eq})
/. (* map Dt over left and right part of (in)equalities *){eq_Equal|eq_GreaterEqual|eq_LessEqual|eq_Greater|eq_Less :>Map[Dt[#]&,eq],
eq_Unequal :> (Message[IDiffInd::illegal,eq]; $Failed)
},
(* Or not yet implemented. Not is rejected *)
(Message[IDiffInd::illegal,fml];$Failed)
]
),
(* Or not yet implemented. Not is rejected *)
(Message[IDiffInd::illegal,fml];$Failed)
]
]
IDiffInd[e_,ODE_]:= ((IDiffInd[e]/.Flatten[Map[ToRules,ODE/.Derivative[1][x_]:>Dt[x]]]) (* any remaining differentials are 0 as not in ODE *)/._Dt->0)


IDiffInd::illegal="Illegal operator in formula `1`, which is not supported by IDiffInd.";
DiffFin::illegal="Illegal operator in formula `1`, which is not supported by IDiffFin.";
DiffInd::illegal=IDiffInd::illegal;


IDiffFin[e_,\[Epsilon]_] :=
 Module[{fml},
fml = LogicalExpand[e];
If[FreeQ[fml,_Not|_ForAll|_Some],
(* during differential induction, all literals need to be attained differentially, hence replace \[Or] by \[And] right away *)
(fml = LogicalExpand[e] /.Or->And;
If[FreeQ[fml,Not[_]|_Or],
(fml/.
(* weaken > to >= and < to <= during DiffInd *)
{eq_Greater :>GreaterEqual@@eq,eq_Less :>LessEqual@@eq})
/. (* map Dt over left and right part of inequalities and add \[Epsilon] or any other positive constant *)
{a_>=b_:>Dt[a]>=Dt[b]+\[Epsilon],a_<=b_:>Dt[a]<=Dt[b]-\[Epsilon],
eq_Equal|eq_Unequal :> (Message[IDiffFin::illegal,eq]; $Failed)
},
(* Or not yet implemented. Not is rejected *)
(Message[IDiffFin::illegal,fml];$Failed)
]
),
(* Or not yet implemented. Not is rejected *)
(Message[IDiffFin::illegal,fml];$Failed)
]
]
IDiffFin[e_,\[Epsilon]_,ODE_]:= ((IDiffFin[e,\[Epsilon]]/.Flatten[Map[ToRules,ODE/.Derivative[1][x_]:>Dt[x]]]) (* any remaining differentials are 0 as not in ODE *)/._Dt->0)


SetAttributes[{DiffInd,IDiffInd,DiffFin,IDiffFin},{Protected,ReadProtected,Locked}]


SymbolicName[n_]:=$SymbolicName[n] (*Unique[\[Lambda]]&*)/;ValueQ[$SymbolicName[n]]
SymbolicName[n_]:=Symbol["\[Lambda]"<>ToString[n]] /;\[Not]ValueQ[$SymbolicName[n]]


SymbolicVector::usage="Gives a vector of dimension n with fully symbolic names as entries.";
SymbolicVector[n_]:=Array[SymbolicName[#]&,n]


SprocedureFormula[a_,e_] :=
Module[{
(* all terms of assumptions, normalized to t>=0 *)
sadditions,sparameters,saddon,targets,normalizedInEqualifyTermsIn},
(* "gets left-hand side terms of atomic formulas in fml normalized to t>=0 or t>0 regardless of propositional form of fml and regardless of whether >= or > has been used)." *)
normalizedInEqualifyTermsIn = Function[{fml},Cases[InEqualifyNormalize[fml],(x_>=0|x_>0:>x),{0,\[Infinity]}]];
(* all terms of assumptions, normalized to t>=0 *)
sadditions=normalizedInEqualifyTermsIn[a];
sparameters=SymbolicVector[Length[sadditions]];
If[Head[sadditions]=!= List \[Or]Head[sparameters]=!=List \[Or]Length[sadditions]!+Length[sparameters],Message[unknown]];
saddon=sparameters.sadditions;
targets=normalizedInEqualifyTermsIn[e];
{And@@Map[Function[{targeteq},targeteq - saddon>=0],targets],
sparameters}
]


Sprocedure[a_,e_] :=
Module[{sdata=SprocedureFormula[a,e],sparameters,sformula,voc},
sparameters=













\!\(\*SubscriptBox[\(sdata\), \(\(\[LeftDoubleBracket]\)\(2\)\(\[RightDoubleBracket]\)\)]\);sformula=













\!\(\*SubscriptBox[\(sdata\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\);
voc=Vocabulary[a\[Implies]e,Heads->True];
If[voc\[Intersection]sparameters!={},Message[Sprocedure::assert]];
If[sformula===True,
True,
Exists[Evaluate[sparameters],Evaluate[And@@(#>=0&/@sparameters)],
ForAll[Evaluate[voc],sformula]] 
]
]


FormalPolynomialList[vars_List] := Map[Times[Sequence@@#]&,Tuples[Map[Function[varspec,Module[{v,d},{v,d}=varspec;
Table[v^n,{n,0,d}]
]],vars]]
]/;MatrixQ[vars]\[And]Dimensions[vars][[2]]==2
FormalPolynomialList[vars_List,deg_Integer] := Select[FormalPolynomialList[vars],
(* this selection may be slightly inefficient but it works *)
(* select only those with total degree <= deg *)
Plus@@Exponent[#,Variables[#]]<=deg&
]/;MatrixQ[vars]\[And]Dimensions[vars][[2]]==2
FormalPolynomialList[vars_List,{deg_Integer}] := Select[FormalPolynomialList[vars],
(* this selection may be slightly inefficient but it works *)
(* select only those with total degree == deg *)
Plus@@Exponent[#,Variables[#]]==deg&
]/;MatrixQ[vars]\[And]Dimensions[vars][[2]]==2


FormalPolynomial[vars_List,deg_Integer] :=FormalPolynomial[Map[{#,deg}&,vars],deg]  /;VectorQ[vars]
FormalPolynomial[vars_List,{deg_Integer}] :=FormalPolynomial[Map[{#,deg}&,vars],{deg}]  /;VectorQ[vars]
FormalPolynomial[vars_List,deg_] := Module[{polylist,sparas},
polylist=FormalPolynomialList[vars,deg];
sparas=SymbolicVector[Length[polylist]];
{sparas.polylist,sparas}
] /;MatrixQ[vars]\[And]Dimensions[vars][[2]]==2
FormalPolynomial[vars_List] := Module[{polylist,sparas},
polylist=FormalPolynomialList[vars];
sparas=SymbolicVector[Length[polylist]];
{sparas.polylist,sparas}
] /;MatrixQ[vars]\[And]Dimensions[vars][[2]]==2


SetAttributes[{Sprocedure,SprocedureFormula,FormalPolynomial,FormalPolynomialList},{Protected,ReadProtected,Locked}]


$numericalODE=False;
$TimeHorizon=\[Infinity];
$verify=True;
CirclePlus=Global`CirclePlus;


$TransFailed[_] := $TransFailed
SetAttributes[$TransFailed, HoldAll]


(* failing trajectories cannot be cured by going any further *)
Transition[_][$TransFailed] := $TransFailed


SetAttributes[$Unknown, HoldAll]


(* unknown trajectories cannot be cured by going any further *)
Transition[_][$Unknown] := $Unknown


(* nondeterministic choice action amongst alternatives *)
Transition[CirclePlus[alternatives__]][State_] :=Module[{alttrans},
(* in parallel follow all alternative transitions from State that do not fail *)(* minor optimization: already perform alttrans before knowing tp *)
alttrans = Union[Select[Map[Transition[#][State]&,{alternatives}],#=!=$TransFailed&]];
(* Print["  alternatives ", alternatives, " are ",alttrans]; *)
Function[tp,
Module[{altstate},
(* we form sets, since, if all trajectories coincide anyway, then there's no need to mess around *) altstate =Union[Select[Through[alttrans[tp]],#=!=$TransFailed&]];Which[Length[altstate]==0, $TransFailed,
Length[altstate]==1,













\!\(\*SubscriptBox[\(altstate\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\),
Length[altstate]>1,Block[{},Message[Transition::nondet,CirclePlus[alternatives],alttrans];
Print["   alternatives at time ", tp," are ", altstate];
(* @xxx arbitrarily follow only ONE of those non-deterministic alternatives *)














\!\(\*SubscriptBox[\(altstate\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\)
]
]
]
]
]


(* empty sequence action *)
Transition[{}][State_] :=
Function[tp,
If[TrueQ[tp!=0],
Message[Transition::nonzerodiscrete, {}, tp];$Unknown,
State]
]


(* guarded continuous evolutions *)
Transition[{evo_evolve,guard[cond_],rest___}][State_] :=
Module[{flow = Transition[evo][State],msw,st,T=$TimeHorizon},
(* ASSUME: eager early mode switches ASAP to determinize *)
msw = Quiet[
Check[
Check[
If[False\[And]$numericalODE,














\!\(\*SubscriptBox[\(NMinimize[st, 0 \[LessEqual] st \[LessEqual] T\  \[And] cond[SComp[flow[st]]], st]\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\),














\!\(\*SubscriptBox[\(Minimize[st, 0 \[LessEqual] st \[LessEqual] T\  \[And] cond[SComp[flow[st]]], st]\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\)
],
Print[" bad guard ",0<=st<=T \[And]cond[SComp[flow[st]]], " for ", evo, " from ", State ];$Failed,
{Minimize::bcons,NMinimize::bcons}
],
(* warn if no solution found but continue without mode switch *)
If[$verify,Message[Transition::verifyf,guard[cond],evo,"warning NMinimize::nosat"]];\[Infinity],
{Minimize::infeas,NMinimize::infeas,Minimize::nosat,NMinimize::nosat}
],
{Minimize::infeas,NMinimize::infeas,Minimize::nosat,NMinimize::nosat}
];
If[msw=!=\[Infinity]\[And]Head[msw]=!=DirectedInfinity\[And]$verify\[And]\[Not]cond[SComp[flow[msw]]],
(*Print[Transition::guardf,guard[cond],evo,flow,msw,SComp[flow[msw]]];*)
Message[Transition::guardf,guard[cond],evo,flow,msw,SComp[flow[msw]]]];
Which[TrueQ[msw==\[Infinity]\[Or]Head[msw]==DirectedInfinity],
(* no mode switch ever occurs hence remain in flow *)
flow,
TrueQ[msw==0],
(* immediate mode switch at time msw==0 *)
(* minor optimization for instant mode switch *)
Function[tp,Transition[{rest}][(SComp[flow[msw]])][tp-msw]]
,
True,
(* mode switch at time msw *)
Function[tp,
\[Piecewise]{
 {(*SComp*)flow[tp], tp<msw},
 {Transition[{rest}][(SComp[flow[msw]])][tp-msw], True}
}
]
]
]


(* guarded continuous evolutions *)
Transition[{evo_evolve,testcond_,rest___}][State_] :=Module[{},
Message[Transition::guardf,testcond,evo,"guard discovery failed for an occurrence of test",$Unknown,State];
$Unknown
] /;  Head[testcond]===test


(* unguarded continuous evolutions *)
Transition[{evo_evolve,rest___}][State_] :=
Module[{flow = Transition[evo][State]},
(* non-guarded continuous evolutions *)
(* no mode switch ever occurs then indefinitely remain in flow (as a non-det choice) *)
If[{rest} !={},Message[Transition::unguarded, evo,{rest}]];
flow
] /;Length[rest]==0\[Or](Head[First[rest]]=!=guard \[And] Head[First[rest]]=!=test)


(* block normalisation *)
Transition[{singleton_}] := Transition[singleton]


(* block normalisation *)
Transition[{seq_List,rest__}] := Transition[Join[seq,{rest}]]


(* distribute alternatives *)
Transition[{CirclePlus[alternatives__],rest__}] := 
Module[{},
Transition[Apply[CirclePlus,Map[{#,rest}&,{alternatives}]]]
]


(* discrete sequence action *)
Transition[{discrete_,rest___}][State_] :=
Module[{jump = Transition[discrete][State]},
Transition[{rest}][jump[0]]
] /; Head[discrete]=!=CirclePlus \[And] Head[discrete]=!=List\[And] Head[discrete]=!=evolve


SetAttributes[test,HoldAll]
test[e_] :=
guard[Function[State,(e/.Table[Symbol["Global`x"<>ToString[i]]-> 













\!\(\*SubscriptBox[\(State\), \(\(\[LeftDoubleBracket]\)\(i\)\(\[RightDoubleBracket]\)\)]\),{i,Length[State]}])]]


(* instant guard test actions *)
Transition[guard[cond_]][State_] :=
Function[tp,
If[TrueQ[tp!=0],Message[Transition::nonzerodiscrete, guard[cond], tp],
\[Piecewise]{
 {State, cond[State]},
 {$TransFailed, True}
}
]
]


Transition[evolve[DE_Equal]] := Transition[evolve[{DE}]]


(* continuous transition along differential equation DE *)
Transition[evolve[DE_List]][State_] :=
Module[{dsols,
sysvars = Table[Symbol["Global`x"<>ToString[i]],{i,Min[Length[DE],Length[State]]}],
eqns = DE\[Union]
Table[Symbol["Global`x"<>ToString[i]][0]== 













\!\(\*SubscriptBox[\(State\), \(\(\[LeftDoubleBracket]\)\(i\)\(\[RightDoubleBracket]\)\)]\),{i,Min[Length[DE],Length[State]]}],
indepvar = Symbol["Global`t"],
(* state variables not mentioned in DE remain just constant *)
constantstatecomponents=Table[Module[{s=













\!\(\*SubscriptBox[\(State\), \(\(\[LeftDoubleBracket]\)\(i\)\(\[RightDoubleBracket]\)\)]\)},Function[tp,s]],{i,Length[DE]+1,Length[State]}]
},
If[Length[DE]<Length[State],Message[Transition::idimension,DE,State,eqns]];
If[Length[DE]>Length[State],Message[Transition::dimension,DE,State,eqns];Return[$Failed]];
(*Print["eqns ", eqns, " sysvars ", sysvars, " at ", State];*)
dsols = 
If[$numericalODE,
(* could slightly optimize by reducing $TimeHorizon if inside sequence. But this is less important. The +1 is to give a right-open interval *)
NDSolve[eqns,sysvars,{indepvar,0,$TimeHorizon+1}],
DSolve[eqns,sysvars,indepvar]
];
If[Head[dsols]==List\[And]Length[dsols]>0\[And]$verify\[And]\[Not]$numericalODE,
Module[{verificationresults = Union[FullSimplify[eqns /. 













\!\(\*SubscriptBox[\(dsols\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\)]]},
If[verificationresults!={True},
Message[Transition::verifyf,eqns,dsols,verificationresults]]]
];
Which[
Head[dsols]===DSolve \[Or]Head[dsols]===NDSolve\[Or]Head[dsols]=!=List\[Or]Length[dsols]==0,(Message[Transition::unsolvable,eqns];Return[$Failed]),
Head[dsols]===List\[And]Length[dsols]==1,Componentwise[Join[sysvars /. 













\!\(\*SubscriptBox[\(dsols\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\),constantstatecomponents]](* unlike non-sequenced discrete transitions, result requires Through *),
Head[dsols]===List\[And]Length[dsols]>1, (Message[Transition::nonunique,eqns,Length[dsols],dsols];
Print["nonunique solution of ", eqns, " is ", dsols];
(* arbitrary non-deterministic choice *)
Componentwise[Join[sysvars/. 













\!\(\*SubscriptBox[\(dsols\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\),constantstatecomponents]])
]
]


SetAttributes[UpdateStateHelper,HoldAll]
SetAttributes[set,HoldAll]


UpdateMerge[Update1_List,Update2_List] :=
(* @todo filter duplicates *)
Join[(* first-win semantics, hence new U2 first *)
Replace[Update2,
HoldPattern[xi_->e_]:> (xi->(e/.Update1)),{1}],
Update1
]
(* optimizations *)
UpdateMerge[{},Update_List] := Update
UpdateMerge[Update_List,{}] := Update


(* Mathematica 6 version *)
UpdateStateHelper[Evstate_,State_,updates_List]:=
Module[{staterules =
Table[Symbol["Global`x"<>ToString[i]]-> 













\!\(\*SubscriptBox[\(Evstate\), \(\(\[LeftDoubleBracket]\)\(i\)\(\[RightDoubleBracket]\)\)]\),{i,Length[Evstate]}],
statecomponentrules =
Table[Symbol["Global`x"<>ToString[i]]-> i,{i,Length[Evstate]}]
},
ReplacePart[State,
Replace[updates,
HoldPattern[xi_->e_]:> (xi/.statecomponentrules)->(e/.staterules),
1]
]
]


Transition[set[HoldPattern[xi_->e_]]][State_] :=Transition[set[{xi->e}]][State]


(* Mathematica 5 version *)
UpdateStateHelper[Evstate_,State_,HoldPattern[xi_=e_]]:=
Module[{staterules =
Table[Symbol["Global`x"<>ToString[i]]-> 













\!\(\*SubscriptBox[\(Evstate\), \(\(\[LeftDoubleBracket]\)\(i\)\(\[RightDoubleBracket]\)\)]\),{i,Length[Evstate]}],
statecomponentrules =
Table[Symbol["Global`x"<>ToString[i]]-> i,{i,Length[Evstate]}]
},
ReplacePart[State,(e/.staterules),(xi/.statecomponentrules)]
]


Transition[set[HoldPattern[xi_=e_]]][State_] :=Function[tp,
If[TrueQ[tp!=0],Message[Transition::nonzerodiscrete, a, tp],
UpdateStateHelper[State,State,xi=e]
]
]


(* discrete jump or projection by performing the given assignment on the state *)
Transition[a:set[HoldPattern[updates_List]]][State_] :=
Function[tp,
If[TrueQ[tp!=0],Message[Transition::nonzerodiscrete, a, tp],
UpdateStateHelper[State,State,updates]
]
]


(* concrete discrete transitions *)
(* discrete jump or projection by performing the given transformation p on the State *)
Transition[transform[p_]][State_] :=
Function[tp,
If[TrueQ[tp!=0],Message[Transition::nonzerodiscrete, transform[p], tp],
p[State]
]
]


(* delegate other user-defined action descriptions to $Transition *)
Transition[otherwise_][State_][tp_] :=
$Transition[otherwise][State][tp]/; ValueQ[$Transition[otherwise][State][tp]]


(* catch unknown action descriptions as a last resort *)
Transition[unknown_][State_][tp_] :=
Module[{},
Message[Transition::unknownaction,unknown];
$Unknown
] /; \[Not]ValueQ[$Transition[unknown][State][tp]]


Transition::unsolvable = "The trajectory for `1` cannot be computed or does not exist.";
Transition::nonunique = "The trajectory for `1` is not unique. Found `2` solutions `3`.";
Transition::idimension= "Notice: some state variables implicitly remain constant as there is a dimensional discrepancy of `1` and `2` yielding `3`.";Transition::dimension= "Error: \[WarningSign] there is a dimensional discrepancy of `1` and `2` yielding `3`.";
Transition::nondet =
"The choices `1` remain non-determinstic `2`. Parallel exploration not currently supported.";
Transition::nonzerodiscrete =
"Discrete transition `1` takes time zero rather than `2`.";
Transition::verifyf = "Verifying solution `2` of `1` failed with `3`.";
Transition::guardf = "Verifying `1` of `2` with flow `3` at time `4` in `5` failed.";
Transition::unguarded = "Warning: Unguarded flow `1` followed by (ignored) actions `2` rather than guard.";
Transition::unknownaction =
"Unknown transition action `1`.";
Transition::unsupported = "Unsupported transition `1`. Not yet implemented.";
Transition::incompatible = "Incompatible transition `1` at `2` with duration `3`";


SetAttributes[{Transition,UpdateMerge,UpdateStateHelper},{Protected,ReadProtected,Locked}]


(* unpacks the state by unwrapping e (as originating from a Transition[...][...][...]) *)
(*SComp[{e__}[z_]] := Through[{e}[z]]
SComp[e_Piecewise] := Head[e][Map[SComp,Apply[List,e]]]
SComp[e_] := e*)
SComp[e_] := e
(* turns list of component functions into a single componentwise function *)
Componentwise[components_List] :=
Function[z, Through[components[z]]]


(* disable logging *)
PrintLog[a__] := Print[a]


AMC[cutoff_,TimeHorizon_,dynamics_,
initialRange_,criticality_:(0&)] :=
Module[{},
PrintLog["Approximation Refinement Model Checking (AMC)"];
For[\[Delta]=1,\[Delta]>cutoff,\[Delta]=\[Delta]/2,
Module[{res},
Print["AMC at ",\[Delta],"-grid"];
{time,res} = Timing[AMCphase[\[Delta],TimeHorizon,dynamics,
initialRange,criticality]];
(*If[Subscript[res, [[1]]]<0,PrintLog["\[WarningSign] unsafe concrete counterexample"];];*)
PrintLog["Result after ", time, " at ", \[Delta], "-grid is ", res];
]
]
]

AMCphase[\[Delta]_,TimeHorizon_,dynamics_,initialRange_,criticality_] := 
Module[{analysetrajectory,useparameters,selectworst},
(* Print["investigate initials ", Discretize[\[Delta]]]; *)
analysetrajectory = Function[xinitial,
Module[{
indepvar = Symbol["Global`t"],
sol,solcriticality,maxcrit,xinit=xinitial},
sol = SComp[Transition[dynamics][xinit][indepvar]];
If[sol===$TransFailed,
{\[Infinity],{}}
,
solcriticality[indepvar_] = criticality[sol]  // FullSimplify;
maxcrit = Minimize[{solcriticality[indepvar],0<=indepvar<=TimeHorizon },
{indepvar}];
{













\!\(\*SubscriptBox[\(maxcrit\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\),Prepend[













\!\(\*SubscriptBox[\(maxcrit\), \(\(\[LeftDoubleBracket]\)\(2\)\(\[RightDoubleBracket]\)\)]\),Symbol["Global`xstate"]->xinit]}
]
]
];
selectworst = Function[{c,d},If[













\!\(\*SubscriptBox[\(c\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\)<













\!\(\*SubscriptBox[\(d\), \(\(\[LeftDoubleBracket]\)\(1\)\(\[RightDoubleBracket]\)\)]\),c,d]];
(* could use early projection to states satisfying initialCondition by Select[...,initialCondition] *)
Fold[selectworst,{\[Infinity],{}},Map[analysetrajectory,Discretize[\[Delta],initialRange]]]
]


Discretize::usage="discrete \[Delta]-grid of points in given range";
Discretize[\[Delta]_,range_] :=
Block[{iranges,relmesh,scaledmesh},
relmesh = Range[0,1,\[Delta]];
scaledmesh[point_,point_]:={point};
scaledmesh[min_,max_]:= Map[Rescale[#,{0,1},{min,max}]&, relmesh];
(* @todo optimize: reorder such that only x,y points are generated that already satisfy initialCondition*)
iranges = Map[scaledmesh[Min[#],Max[#]]&,range];
Union[Flatten[Apply[Outer, Prepend[iranges, List]], Length[range]-1]]
]


SetAttributes[{AMC,AMCphase,Discretize},{Protected,ReadProtected,Locked}]


(* add Snapshot and Animation export options *)
PlotTrace[actions_,x0_,coordinates_List,opts:OptionsPattern[]]:=
Module[{T=OptionValue[TimeHorizon],sol,plottrace,anim,plotState=OptionValue[PlotState],coords=If[Length[Dimensions[coordinates]]===1,
(* turn coordinates into a List of Lists *)
{coordinates},
coordinates]},
If[TrueQ[OptionValue[PlotState]==Automatic],plotState=Function[{State},Graphics[Map[Point[State[[#]]]&,coords]]]];
sol=SComp[Transition[actions][x0][t]];
plottrace=ParametricPlot[Map[sol[[#]]&,coords],{t,0,T},
Evaluate[Sequence@@FilterRules[{opts},Options[ParametricPlot]]]];
If[TrueQ[OptionValue[Animate]],
anim=Animate[
Evaluate[Show[Evaluate[plotState[sol]],plottrace,Evaluate[Sequence@@FilterRules[{opts},Options[Graphics]]]
]],
{t,0,T},
Evaluate[Sequence@@FilterRules[{opts}(*Join[{opts},{AnimationRunning->False}]*),Options[Animate]]]
],
plottrace
]
]


SetAttributes[PlotTrace,{Protected,ReadProtected,Locked}]


(* findinstance based *)
IFindTransition[prestate_List,eqns_List,t_,inv_,goal_,opts:OptionsPattern[]]:=
Module[{dsols,indepvar=t,
depvars=DifferentialSymbols[eqns],dsol,msw,cex,st=t,cext,
prestate0,invt,goalt,invts,goalts,
T=OptionValue[TimeHorizon],sampling,sample,reachedstate},
invt=ExprAt[inv,depvars,indepvar];
goalt=ExprAt[goal,depvars,indepvar];
prestate0=prestate/.(x_->a_)->(x[0]->a);
(* @todo could already use known initial values rather than symbolic initial values and replacements *)
dsols=IDSolve[eqns,indepvar]/.x_[0]:>x;
Which[
Head[dsols]===DSolve \[Or]Head[dsols]===NDSolve\[Or]Head[dsols]=!=List\[Or]Length[dsols]==0,(Message[Transition::unsolvable,eqns];Return[$Failed]),
Head[dsols]===List\[And]Length[dsols]==1,
dsol=dsols[[1]],
Head[dsols]===List\[And]Length[dsols]>1, (Message[Transition::nonunique,eqns,Length[dsols],dsols];
dsol=dsols[[1]])
];
invts=invt/.dsol/.prestate;
goalts=goalt/.dsol/.prestate;
Print["looking at ",goalts, " in ",invts, " with " ,st," giving ",0<=st\[And]invts\[And]goalts];
(* can we reach goal? *)
cex =IFindInstance[0<=st\[And]invts\[And]goalts];
If[cex=={},
(* did not find reaching goal *){},
Print["possible cex ", cex];
cext=(indepvar/.cex[[1]]);
reachedstate=Join[
cex[[1]],
prestate,
(* diff post state table *)
Map[(#->(ExprAt[#,depvars,indepvar]
/.dsol/.prestate/.indepvar->cext))&,DifferentialSymbols[eqns]]
];
(* did we leave inv before? *)
Quiet[Check[
If[IFindInstance[0<=st<=cext \[And]\[Not]invts]=={},
reachedstate,
(* violated inv before reaching goal *)
{}
]
,
(* doubtful as inv-violation check did not work *)
Print["case of doubt ",0<=st<=cext \[And]\[Not]invts];
reachedstate
,
FindInstance::nsmet],FindInstance::nsmetTODO]
]
]


IFindTransition[initial_,initialUpdate_List,eqns_List,t_,inv_,goal_,opts:OptionsPattern[]] :=
Module[{cexs,fullvocab},
fullvocab=Complement[Join[Vocabulary[initial\[And](inv/.initialUpdate)],Vocabulary[eqns]],
{t}
];
Catch[
Function[initialstate,
Module[{state,res},
state=UpdateMerge[initialstate,initialUpdate];
Print["examine ",state];
res=IFindTransition[state,eqns,t,inv,goal,opts];
If[Head[res]==List\[And]Length[res]>0,
Throw[res],res]
]
]/@FindInstance[initial\[And](inv/.initialUpdate),fullvocab,
Reals,OptionValue[Instances]];
{}
]
]


SetAttributes[IFindInstance,{Protected,ReadProtected,Locked}]


ExprAt::usage="ExprAt[expr,vars,t] adds parameter t to all occurrences of vars in expr.";
ExprAt[expr_,vars_,t_] := expr/.Map[(#->#[t])&,vars]


End[]
EndPackage[]
