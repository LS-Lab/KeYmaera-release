// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe Germany
//                           Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
// This file contains rules for handling hybrid programs


\include ruleSetsDeclarations;
//\include dlPropRule;

\optionsDecl{
}

/*\sorts{
  R;
}*/

\schemaVariables {
  // non-trace modalities
  \modalOperator { diamond, box } #allmodal;
  \modalOperator { diamond } #dia;
  \modalOperator { box } #box;

  // mixed trace/non-trace modalities
  // all modalities including traces
  \modalOperator { diamond, box, throughout /*, finally*/} #allmodaltr;
  \modalOperator { diamond /*, finally*/} #diatr;
  \modalOperator { box, throughout } #boxtr;

  // only trace modalities
  // all trace modalities
  \modalOperator { throughout /*, finally*/ } #trace;
  \modalOperator { throughout } #boxtbox;

  \formula phi, psi, post, inv, target;
  \term R trm;  
  \skolemTerm R sk ;
  \variables R u;

  \term R q;
  \skolemTerm R queryValue ;

  \program Literal #lit ;
  \program Statement #alpha;
  \program[list] Statement #gamma;

  \program Expression #e;
  \program SimpleExpression #se, #se0, #se1 ;
  \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv ;
  \program[list] Statement #s, #s0, #s1 ;  

  \program Type #t;
  \program Variable #v, #v0, #v1, #v2, #boolv, #a, #a0, #a1 ;

   \program Variable #loc ;
   \variables R iv, iv2, iv3, t,n ;
   \term R idx;
   \term R #sval, #byte1, #byte2; 
   
   \program DLProgram #dl, #dl2;
	\program DLFormula #dlform;
	\program DLExpression #dle;
	\program DLVariable #dlvar;
	\program RandomAssign #rdm;
	\program DiffSystem #diffsystem;
	\program DLVariableDeclaration #decl;

  \formula b,c,d;
  \formula[rigid] br, cr;

 \location[list] #modifies;
 \formula anon1, anon2, anon3;

}

/*\functions{
  R neg(R);
  R sub(R,R);
  R add(R,R);
  R mul(R,R);
  R div(R,R);
  R exp(R,R);
  R sin(R);
  R cos(R);
  R tan(R);
  R E;
}

\predicates{   
  \nonRigid inReachableState;
  gt(R,R);
  geq(R,R);
  equals(R,R);
  leq(R,R);
  lt(R,R);
  neq(R,R);
}*/

\rules {
  subst_to_eq { \find ({\subst u; trm} target) \sameUpdateLevel
                \varcond (\new(sk, \dependingOn(trm)))
                \replacewith ({\subst u; sk} target)
                \add (sk = trm ==>)
                \heuristics (simplify) };

  apply_subst { \find ({\subst u; trm} phi)
                // it is enough to rebuild the same term, as substitutions
                // are automatically applied in this situation
                \replacewith ({\subst u; trm} phi)
                \heuristics (try_apply_subst) };

 eliminate_variable_decl {
 	\find(\modality{#allmodaltr}#decl\endmodality(post))
	\replacewith(post)
	\heuristics(simplify)
 };

////////////////////////////////////////
//
// program rules
//
 
 if_then_else_right {
 	\find(==>\modality{#allmodaltr} if(#dlform) then #dl else #dl2 fi\endmodality(post))
	"#dlform": \replacewith(#dlform ==> \modality{#allmodaltr} #dl\endmodality(post)); 
	"! #dlform": \replacewith(! #dlform ==> \modality{#allmodaltr} #dl2\endmodality(post)) 
\heuristics(simplify_prog)

 };

 if_then_right {
 	\find(==>\modality{#allmodaltr} if(#dlform) then #dl fi\endmodality(post))
	"#dlform": \replacewith(#dlform ==> \modality{#allmodaltr} #dl\endmodality(post)); 
	"! #dlform": \replacewith(! #dlform ==> post) 
	\heuristics(simplify_prog)

 };

 if_then_else_left {
 	\find(\modality{#allmodaltr} if(#dlform) then #dl else #dl2 fi\endmodality(post) ==>)
	"#dlform": \replacewith(#dlform, \modality{#allmodaltr} #dl\endmodality(post) ==>); 
	"! #dlform": \replacewith(! #dlform, \modality{#allmodaltr} #dl2\endmodality(post) ==>) 
	\heuristics(simplify_prog)
 };

 if_then_left {
 	\find(\modality{#allmodaltr} if(#dlform) then #dl fi\endmodality(post) ==>)
	"#dlform": \replacewith(#dlform, \modality{#allmodaltr} #dl\endmodality(post) ==>); 
	"! #dlform": \replacewith(! #dlform, post ==>) 
	\heuristics(simplify_prog)

 };

 modality_split_left { 
 	\find (\modality{#allmodal}#dl;#dl2\endmodality(post) ==>) 
 	"Modality Split": \replacewith(\modality{#allmodal}#dl\endmodality(\modality{#allmodal}#dl2\endmodality(post)) ==>) 
 	\heuristics(simplify_prog)
};

 modality_split_right { 
 	\find (==> \modality{#allmodal}#dl;#dl2\endmodality(post)) 
 	"Modality Split": \replacewith(==>\modality{#allmodal}#dl\endmodality(\modality{#allmodal}#dl2\endmodality(post))) 
 	\heuristics(simplify_prog)
};

 through_split_right { 
 	\find (==>\modality{#boxtbox}#dl;#dl2\endmodality(post)) 
 	"Modality Split": \replacewith(==> \modality{throughout}#dl\endmodality(post) & \modality{box}#dl\endmodality(\modality{throughout}#dl2\endmodality(post))) 
 	\heuristics(simplify_prog)
};

 through_split_left { 
 	\find (\modality{#boxtbox}#dl;#dl2\endmodality(post) ==>) 
 	"Modality Split": \replacewith(\modality{throughout}#dl\endmodality(post) & \modality{box}#dl\endmodality(\modality{throughout}#dl2\endmodality(post)) ==>) 
 	\heuristics(simplify_prog)
};

/*diamond_quest { \find (\modality{#dia}?#dlform\endmodality(post)) \replacewith(#prog2logic(#dlform) & post) \heuristics(simplify_prog)};
box_quest { \find (\modality{#box}?#dlform\endmodality(post)) \replacewith(#prog2logic(#dlform) -> post) \heuristics(simplify_prog)};*/

diamond_quest_left { 
 	\find (\modality{#dia}?#dlform\endmodality(post) ==>) 
	\replacewith(#dlform, post ==>) 
	\heuristics(simplify_prog)
};

diamond_quest_right { 
 	\find (==>\modality{#dia}?#dlform\endmodality(post)) 
	\replacewith(==> #dlform & post) 
	\heuristics(simplify_prog)
};

box_quest_left { 
 	\find (\modality{#box}?#dlform\endmodality(post) ==>) 
	\replacewith(#dlform -> post ==>) 
	\heuristics(simplify_prog)
};

box_quest_right { 
 	\find (==>\modality{#box}?#dlform\endmodality(post)) 
	\replacewith(#dlform ==> post) 
	\heuristics(simplify_prog)
};

boxtbox_quest_right { 
 	\find (==>\modality{#boxtbox}?#dlform\endmodality(post)) 
	\replacewith(==>post) 
	\heuristics(simplify_prog)
};

boxtbox_quest_left { 
 	\find (\modality{#boxtbox}?#dlform\endmodality(post)==>) 
	\replacewith(post ==>) 
	\heuristics(simplify_prog)
};

box_choice_right { 
 	\find (==>\modality{#boxtr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#boxtr}#dl\endmodality(post));
	\replacewith(==>\modality{#boxtr}#dl2\endmodality(post)) 
	\heuristics(simplify_prog)
};

box_choice_left { 
 	\find (\modality{#boxtr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#boxtr}#dl\endmodality(post), \modality{#boxtr}#dl2\endmodality(post) ==>) 
	\heuristics(simplify_prog)
};

diamond_choice_right { 
 	\find (==>\modality{#diatr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#diatr}#dl\endmodality(post), \modality{#diatr}#dl2\endmodality(post)) 
	\heuristics(simplify_prog)
};

diamond_choice_left { 
 	\find (\modality{#diatr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#diatr}#dl\endmodality(post)==>);
	\replacewith(\modality{#diatr}#dl2\endmodality(post)==>) 
	\heuristics(simplify_prog)
};
 
 // loop handling
 /*
 // These rules do not work, as KeY cannot reintroduce the *. Further, they are wrong
 diamond_unwind { 
 	\find (\modality{#dia}#dl* \endmodality(post)) 
	\replacewith(post | \modality{#dia}#dl\endmodality(\modality{#dia}(#dl)*\endmodality(post))) 
};
 box_unwind { 
 	\find (\modality{#box}#dl* \endmodality(post)) 
	\replacewith(post & \modality{#box}#dl\endmodality(\modality{#box}(#dl)*\endmodality(post)))
};
*/

loop_unwind_box { 
	\find (\modality{#box}#dl* \endmodality(post)) 
	\replacewith(post & (#dlunwind(\modality{box}#dl\endmodality(post))))
};

loop_unwind_dia { 
	\find (\modality{#dia}#dl* \endmodality(post)) 
	\replacewith(post | (#dlunwind(\modality{#dia}#dl\endmodality(post))))
};

loop_unwind_trace { 
	\find (\modality{#trace}#dl* \endmodality(post)) 
	\replacewith(#dlunwind(\modality{#trace}#dl\endmodality(post)))
};

//@todo add loop_inv_boxtbox trace versions for loops


 loop_inv_box_quan { \find (==> \[#dl*\]post) 
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==>  #dlUniversalClosure(\[#dl\]true, (inv -> \[#dl\]inv)));
    "Use Case":
          \replacewith (==> #dlUniversalClosure(\[#dl\]true, inv -> post)) 
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "loop_invariant_quan"}; 

 loop_inv_box { \find (==> \[#dl*\]post) 
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Body Preserves Invariant":
          \replacewith (==>  #dlintroNewAnonUpdate(\[#dl\]true, (inv -> \[#dl\]inv)));
    "Use Case":
          \replacewith (==> #dlintroNewAnonUpdate(\[#dl\]true, inv -> post)) 
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "loop_invariant"};
          
   loop_var_dia { \find (==> \<#dl*\>post)
    \varcond(\notFreeIn(n, post))
    "Invariant Initially Valid":
          \replacewith (==> \exists n; inv );
    "Body Preserves Invariant":
          \replacewith (==>  #dlUniversalClosure(\[#dl\]true, \forall n; (inv -> \<#dl\> {\subst n; n-1}inv)));
    "Use Case":
          \replacewith (==> (\exists n; inv) -> post) 
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "loop_variant"}; 
           

 generalisation { \find (==> \modality{#allmodal}#dl\endmodality(post))
    "Generalisation Holds":
          \replacewith (==> \modality{#allmodal}#dl\endmodality(psi) );
    "Valid Generalisation":
          \replacewith (==>  #dlUniversalClosure(\modality{#allmodal}#dl\endmodality(post), (psi -> post)))
 }; 

 diffind { \find (==> \[#diffsystem\]post)
      \varcond(\isFirstOrderFormula(post))
    "Invariant Initially Valid":
          \replacewith (#invariantPart(\[#diffsystem\]post) ==> post );
    "ODE Preserves Invariant":
          \replacewith (==>  #dlUniversalClosure(\[#diffsystem\]true, #DiffInd(\[#diffsystem\]post)))
          \displayname "diffind"
 }; 

 diff_weaken_approx { \find (==> \[#diffsystem\]post)
          \replacewith (#invariantPart(\[#diffsystem\]post)==> post )
          \displayname "diff_weaken approximation"
 }; 

 diff_strengthen { \find (==> \[#diffsystem\]post)
      \varcond(\isFirstOrderFormula(psi))
    "Invariant Valid":
          \replacewith (==> \[#diffsystem\] psi );
    "Augmented Invariant":
          \replacewith (==>  #diffAdjoin(\[#diffsystem\]post,psi))
 }; 

 ODESolve_left { 
 	\find (\modality{#allmodal}#diffsystem \endmodality(post) ==>) 
	\replacewith(#ODESolve(\modality{#allmodal}#diffsystem\endmodality(post)) ==>)  
	\heuristics(simplify_prog)
 };

 ODESolve_right { 
 	\find (==>\modality{#allmodal}#diffsystem \endmodality(post)) 
	\replacewith(==>#ODESolve(\modality{#allmodal}#diffsystem\endmodality(post)))  
	\heuristics(simplify_prog)
 };

 ODESolve_boxtbox_left { 
 	\find (\modality{#boxtbox}#diffsystem \endmodality(post) ==>) 
	\replacewith(\modality{box}#diffsystem \endmodality(post) ==>)  
	\heuristics(simplify_prog)
 };

 ODESolve_boxtbox_right { 
 	\find (==>\modality{#boxtbox}#diffsystem \endmodality(post)) 
	\replacewith(==>\modality{box}#diffsystem \endmodality(post))  
	\heuristics(simplify_prog)
 };

 
 assignment_to_update_left {
 	\find (\modality{#allmodal}#dlvar := #dle \endmodality(post) ==>) 
	\replacewith(({#dlvar := #dle} post) ==>) 
	\heuristics(simplify_prog)
 };

 assignment_to_update_right {
 	\find (==>\modality{#allmodal}#dlvar := #dle \endmodality(post)) 
	\replacewith(==>({#dlvar := #dle} post)) 
	\heuristics(simplify_prog)
 };

 assignment_boxtbox_left {
     \find (\modality{#boxtbox}#dlvar := #dle \endmodality(post) ==>)
     \replacewith(post & ({#dlvar := #dle}(post)) ==>)
     \heuristics(simplify_prog)
 };

 assignment_boxtbox_right {
     \find (==>\modality{#boxtbox}#dlvar := #dle \endmodality(post))
     \replacewith(==> post & ({#dlvar := #dle}(post)))
     \heuristics(simplify_prog)
 };

random_ass_box_left {
	\find (\modality{#box}#rdm\endmodality(post) ==>)  
	\replacewith(#randomass(\modality{#box}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
};

random_ass_box_right {
	\find (==>\modality{#box}#rdm\endmodality(post))  
	\replacewith(==>#randomass(\modality{#box}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
};

random_ass_boxtbox_left { 
	\find (\modality{#boxtbox}#rdm\endmodality(post)==>)
	\replacewith(post & (\modality{box}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
};

random_ass_boxtbox_right { 
	\find (==>\modality{#boxtbox}#rdm\endmodality(post))  
	\replacewith(==>post & (\modality{box}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
};

random_ass_dia_left { 
	\find (\modality{#dia}#rdm\endmodality(post)==>)  
	\replacewith(#randomass(\modality{#dia}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
};

random_ass_dia_right { 
	\find (==>\modality{#dia}#rdm\endmodality(post))  
	\replacewith(==>#randomass(\modality{#dia}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
};


////////////////////////////////////////
//
// Math Predicate Rules
//
   simplify_form {\find (phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#simplify(phi, true)) 
         \displayname "simplify"};

   simplify_form_right {\find (==> phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (==> #simplify(phi, true)) 
		 \heuristics(mathematica_simplify)
         \displayname "simplify"};

   simplify_form_left {\find (phi ==>) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#simplify(phi, true) ==>) 
		 \heuristics(mathematica_simplify)
         \displayname "simplify"};

   simplify_form_ass_right {
   \assumes( post ==>)
   \find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
      "Simplify Assumption": \replacewith ( ==> #simplify(phi, post)) 
         \displayname "simplify_ass_from_left"};

   simplify_form_not_ass {
   \assumes( ==> post)
   \find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
      "Simplify Assumption": \replacewith ( ==> #simplify(phi, ! post)) 
         \displayname "simplify_ass_from_right"};

   simplify_form_ass_left {
   \assumes( post ==> )
   \find ( phi ==>)   
   		\varcond( \isFirstOrderFormula(phi))
      \replacewith ( #simplify(phi, post) ==> ) 
         \displayname "simplify_ass_from_left"};

   full_simplify_form {\find (phi)  
   		\varcond( \isFirstOrderFormula(phi))
      "FullSimplify": \replacewith (#fullsimplify(phi)) 
         \displayname "full_simplify"};

   reduce_form {\find (phi)
   		\varcond( \isFirstOrderFormula(phi))
      "Reduce": \replacewith (#reduce(phi)) 
         \displayname "reduce"};

   reduce_form_right {\find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
      "Reduce": \replacewith (==> #reduce(phi)) 
	  	\heuristics(mathematica_reduce)
         \displayname "reduce"};

   reduce_form_left {\find (phi ==>)  
   	\varcond( \isFirstOrderFormula(phi))
      "Reduce": \replacewith (#reduce(phi) ==>) 
	  	\heuristics(mathematica_reduce)
         \displayname "reduce"};
	
////////////////////////////////////////
//
// Rules for handling quantifiers
//
   
  // Gamma rules

  all_left { 
  	\find (\forall u; b ==>) 
  	\replacewith ({\subst u; q}(b) ==>) 
  	\heuristics(gamma) 
  };

  ex_right { \find (==> \exists u; b)
             \replacewith (==> {\subst u; q}(b))
  	     \heuristics(gamma) };
  	     
  /*all_left_hide { \find (\forall u; b ==>) \replacewith ({\subst u; q}(b) ==>)
		    \addrules ( insert_hidden { \add (\forall u; b ==>) } )
                    \heuristics(gamma_destructive) };
  ex_right_hide { \find (==> \exists u; b) \replacewith (==> {\subst u; q}(b))
		    \addrules ( insert_hidden { \add (==> \exists u; b) } )
                    \heuristics(gamma_destructive) }; */
   
  // delta rules
  all_right { \find (==> \forall u; b) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith (==> {\subst u; sk}b) \heuristics (delta) };
  ex_left { \find (\exists u; b ==>) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith ({\subst u; sk}b ==>) \heuristics (delta) };

////////////////////////////////////////
//
// Rules for handling inequations
// Transformations normalising inequalities to one of the forms
//   a>b ==> 
//   a>=b ==> 
//
  less_right { \find (==> lt(trm, q))
		\replacewith (geq(trm, q) ==>) \heuristics (inequation_normalization) };

  less_equal_right { \find (==> leq(trm, q))
		"Less Equal Right": \replacewith (gt(trm, q) ==>) \heuristics (inequation_normalization) };

  less_left { \find (lt(trm,q) ==>)
		"Less Left": \replacewith (gt(q, trm) ==>) \heuristics (inequation_normalization) };

  less_equal_left { \find (leq(trm,q) ==>)
		"Less Equal Left": \replacewith (geq(q, trm) ==>) \heuristics (inequation_normalization) };

  greater_right { \find (==> gt(trm, q))
		"Greater Right": \replacewith (geq(q,trm) ==>) \heuristics (inequation_normalization) };

  greater_equal_right { \find (==> geq(trm, q))
		"Greater Equal Right": \replacewith (gt(q, trm) ==>) \heuristics (inequation_normalization) };

  // further inequation normalization

  inequality_right { \find (==> neq(trm, q))
		"Inequality Right": \replacewith (equals(q, trm) ==>) \heuristics (inequation_normalization) };

  simplify_greater_greater_equal_left { \assumes (gt(trm,q) ==> )
		\find (geq(trm,q) ==>)
		\replacewith (==>) \heuristics (inequation_normalization) };

  simplify_greater_equal_greater_equal_left {
                \assumes (geq(trm,q)==>)  /* this part will be removed by simplify_equal_greater_equal */
		\find (geq(q,trm)==>)
		\replacewith (equals(trm,q) ==>) \heuristics (inequation_normalization) };
  
  simplify_equal_greater_equal_left { \assumes (equals(trm,q) ==> )
		\find (geq(trm,q) ==>)
		\replacewith (==>) \heuristics (inequation_normalization) };
  simplify_equal_greater_equal_left2 { \assumes (equals(trm,q) ==> )
		\find (geq(q,trm) ==>)
		\replacewith (==>) \heuristics (inequation_normalization) };

  close_ineq { \assumes ( gt(trm, q) ==>)
  	\find( gt(q, trm) ==>)
	\closegoal
	\heuristics(closure)
  };

  close_ineq_eq_1 { \assumes ( gt(trm, q) ==>)
  	\find( equals(q, trm) ==>)
	\closegoal
	\heuristics(closure)
  };

  close_ineq_eq_2 { \assumes ( gt(trm, q) ==>)
  	\find( equals(trm, q) ==>)
	\closegoal
	\heuristics(closure)
  };

////////////////////////////////////////
//
// Propositional Rules
//

  // closing goals
  close_goal       { \assumes (b ==>) \find (==> b) \closegoal 
			    \heuristics(closure) };
  close_goal_antec { \assumes (==> b) \find (b ==>) \closegoal };
  close_by_false   { \find (false ==>) \closegoal \heuristics(closure) };
  close_by_true    { \find (==> true) \closegoal \heuristics(closure) };
  

  // simplify rules for "ReplaceKnownStrategy"
  replace_known_left  { \assumes ( b ==> ) \find ( b ) \sameUpdateLevel \replacewith ( true )
			   \heuristics(replace_known) \noninteractive };
  replace_known_right { \assumes ( ==> b ) \find ( b ) \sameUpdateLevel \replacewith ( false )
			   \heuristics(replace_known) \noninteractive };


  // junctor rules
  true_left    { \find (true ==>) \replacewith(==>) \heuristics(concrete) };
  false_right  { \find (==> false) \replacewith(==>) \heuristics(concrete) };

  not_left  { \find (! b ==>) \replacewith(==> b) \heuristics(alpha) };
  not_right { \find (==> ! b) \replacewith(b ==>) \heuristics(alpha) };

  imp_left  { \find (b -> c ==>) 
		\replacewith(==> b); 
                \replacewith(c ==>)
	      \heuristics(split,beta) };
  imp_right { \find (==> b -> c) \replacewith(b ==> c) 
		\heuristics(alpha) };

  and_left  { \find (b & c ==>) \replacewith(b, c ==>) \heuristics(alpha) };
  and_right { \find (==> b & c) \replacewith(==> b); \replacewith(==> c) 
                    \heuristics(split,beta) };
  or_left   { \find (b | c ==>) 
              "#b":\replacewith(b ==>); "#c":\replacewith(c ==>)
              \heuristics(split,beta) };
  or_right  { \find (==> b | c) \replacewith(==> b, c) \heuristics(alpha) };

//  equiv_left   { \find (b <-> c ==>) 
//		      \replacewith(b -> c, c -> b ==>)
//                    \heuristics(alpha_concrete) };

  equiv_left   { \find (b <-> c ==>) 
		      \replacewith(b, c ==>); 
                      \replacewith(==> b, c)
                    \heuristics(split,beta) };
  
//  equiv_right  { \find (==> b <-> c) 
//		      \replacewith(==> b & c, !b & !c)
//                    \heuristics(alpha_concrete) };

  equiv_right  { \find (==> b <-> c) 
		      \replacewith(b ==> c);
                      \replacewith(c ==> b)
                    \heuristics(split,beta) };

  /* These `recursive' rules are commented out, because this 
     keyword is not yet supported.
  imp_left_rec { \find (b -> c ==>)  \recursive 
		   \replacewith(==> b); 
                   \replacewith(c ==>) };
  and_right_rec { \find (==> b & c)  \recursive 
		    \replacewith(==> b); 
                    \replacewith(==> c) };
  or_left_rec { \find (b | c ==>)  \recursive
		  \replacewith(b ==>); 
                  \replacewith(c ==>) };
  */
  
  split_or_strong { \find (b | c ==>) 
		      \replacewith (b ==>); 
                      \replacewith(c ==> b) };

///////////////////////////////////////////////////////////////////////////////
// 8 beta rules that perform an implicit cut, i.e. that introduce lemmas.
// The treated cases occur frequently when splitting programs with if-branches.
// These rules are given slightly higher priority than the usual beta rules in
// strategy "Simple JavaCardLD"

  imp_left_lemma { \assumes (!b -> d ==>) \find (b -> c ==>)
                   \replacewith (==> b);
                   \replacewith (b, c ==>)
                   \heuristics(beta,beta_lemma) };

  imp_left_lemma_2 { \assumes (==> !b & d) \find (b -> c ==>)
                     \replacewith (==> b);
                     \replacewith (b, c ==>)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  imp_left_lemma_3 { \assumes (b -> d ==>) \find (!b -> c ==>)
                     \replacewith (b ==>);
                     \replacewith (c ==> b)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  imp_left_lemma_4 { \assumes (==> b & d) \find (!b -> c ==>)
                     \replacewith (b ==>);
                     \replacewith (c ==> b)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  and_right_lemma { \assumes (!b -> d ==>) \find (==> b & c)
                    \replacewith (==> b);
                    \replacewith (b ==> c)
                    \heuristics(beta,beta_lemma) };

  and_right_lemma_2 { \assumes (==> !b & d) \find (==> b & c)
                      \replacewith (==> b);
                      \replacewith (b ==> c)
                      \heuristics(beta,beta_lemma)
                      \displayname "and_right_lemma" };

  and_right_lemma_3 { \assumes (b -> d ==>) \find (==> !b & c)
                    \replacewith (b ==>);
                    \replacewith (==> b, c)
                    \heuristics(beta,beta_lemma) };

  and_right_lemma_4 { \assumes (==> b & d) \find (==> !b & c)
                      \replacewith (b ==>);
                      \replacewith (==> b, c)
                      \heuristics(beta,beta_lemma)
                      \displayname "and_right_lemma" };

///////////////////////////////////////////////////////////////////////////////

  shift_paren_and { \find (b & (c & d)) \replacewith ((b & c) & d)
                        \heuristics(simplify) };
  shift_paren_or  { \find (b | (c | d)) \replacewith ((b | c) | d)
                        \heuristics(simplify) };
  commute_and { \find (b & c) \replacewith (c & b) };
  commute_or  { \find (b | c) \replacewith (c | b) };
  rotate_and { \find (b & (c & d)) \replacewith (c & (b & d)) };
  rotate_or  { \find (b | (c | d)) \replacewith (c | (b | d)) };
  
  // equivalence replacement
  insert_eqv_once_lr { \find (br <-> cr ==>) 
			\addrules( insert_eqv{ \find (br) \replacewith (cr)} )
		       \heuristics(simplify) \noninteractive };
  insert_eqv_once_rl { \find (br <-> cr ==>) 
			 \addrules( insert_eqv{ \find (cr) \replacewith (br)} )
                       \heuristics(simplify) \noninteractive };

  insert_eqv_lr { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (br) \replacewith (cr) 
					  \heuristics(simplify) } ) };
  insert_eqv_rl { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (cr) \replacewith (br) 
					  \heuristics(simplify) } ) };

  // simplification
  double_not { \find ( ! ( ! b)) \replacewith (b) \heuristics(concrete) };

  concrete_not_1  { \find (! true) \replacewith (false) \heuristics(concrete) };
  concrete_not_2  { \find (! false) \replacewith (true) \heuristics(concrete) };

  concrete_impl_1 { \find (true -> b) \replacewith (b) \heuristics(concrete) };
  concrete_impl_2 { \find (false -> b) \replacewith (true) \heuristics(concrete) };
  concrete_impl_3 { \find (b -> false) \replacewith (! b) \heuristics(concrete) };
  concrete_impl_4 { \find (b -> true) \replacewith (true) \heuristics(concrete) };

  concrete_and_1  { \find (true & b) \replacewith (b) \heuristics(concrete) };
  concrete_and_2  { \find (false & b) \replacewith (false) \heuristics(concrete) };
  concrete_and_3  { \find (b & true) \replacewith (b) \heuristics(concrete) };
  concrete_and_4  { \find (b & false) \replacewith (false) \heuristics(concrete) };

  concrete_or_1   { \find (true | b) \replacewith (true) \heuristics(concrete) };
  concrete_or_2   { \find (false | b) \replacewith (b) \heuristics(concrete) };
  concrete_or_3   { \find (b | true) \replacewith (true) \heuristics(concrete) };
  concrete_or_4   { \find (b | false) \replacewith (b) \heuristics(concrete) };
  
  concrete_eq_1   { \find (true <-> b) \replacewith (b) \heuristics(concrete) };
  concrete_eq_2   { \find (false <-> b) \replacewith (! b) \heuristics(concrete) };
  concrete_eq_3   { \find (b <-> true) \replacewith (b) \heuristics(concrete) };
  concrete_eq_4   { \find (b <-> false) \replacewith (! b) \heuristics(concrete) };
  


  eq_imp  { \find (b -> b) \replacewith (true) \heuristics(simplify) };
  eq_and  { \find (b & b) \replacewith (b) \heuristics(simplify) };
  eq_or   { \find (b | b) \replacewith (b) \heuristics(simplify) };
  eq_eq   { \find (b <-> b) \replacewith (true) \heuristics(simplify) };
/*
  eq_imp  { \find (b -> b) \replacewith (true) };
  eq_and  { \find (b & b) \replacewith (b) };
  eq_or   { \find (b | b) \replacewith (b) };
  eq_eq   { \find (b <-> b) \replacewith (true) };
*/  

/*
  known_not_1_r  { \assumes (b ==>) \find (==> ! b) \replacewith (==> false) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_not"};
  known_not_1_l  { \assumes (b ==>) \find ( ! b ==>) \replacewith (false ==>) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_not"};

  known_not_2_r  { \assumes (==> b) \find (==> ! b) \replacewith (==>true) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_not"};
  known_not_2_l  { \assumes (==> b) \find (! b ==>) \replacewith (true==>) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_not"};

  known_impl_1_r { \assumes (b ==>) \find (==> b -> c) \replacewith (==>c) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_impl"};
  known_impl_1_l { \assumes (b ==>) \find (b -> c ==>) \replacewith (c==>) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_impl"};

  known_impl_2_r { \assumes (==> b) \find (==> b -> c) \replacewith (==>true) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_impl"};
  known_impl_2_l { \assumes (==> b) \find (b -> c ==>) \replacewith (true==>) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_impl"};


  known_impl_3_r { \assumes (==> b) \find (==> c -> b) \replacewith (==>! c) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_impl"};
  known_impl_3_l { \assumes (==> b) \find (c -> b ==>) \replacewith (! c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_impl"};

  known_impl_4_r { \assumes (b ==>) \find (==> c -> b) \replacewith (==>true) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_impl"};
  known_impl_4_l { \assumes (b ==>) \find (c -> b ==>) \replacewith (true==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_impl"};

  known_and_1_r  { \assumes (b ==>) \find (==> b & c) \replacewith (==>c) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_and"};
  known_and_1_l  { \assumes (b ==>) \find (b & c ==>) \replacewith (c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_and"};

  known_and_2_r  { \assumes (==> b) \find (==> b & c) \replacewith (==>false) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_and"};
  known_and_2_l  { \assumes (==> b) \find (b & c ==>) \replacewith (false==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_and"};


  known_and_3_r  { \assumes (b ==>) \find (==> c & b) \replacewith (==>c) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_and"};
  known_and_3_l  { \assumes (b ==>) \find (c & b ==>) \replacewith (c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_and"};

  known_and_4_r  { \assumes (==> b) \find (==> c & b) \replacewith (==>false) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_and"};
  known_and_4_l  { \assumes (==> b) \find (c & b  ==>) \replacewith (false==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_and"};

  known_or_1_l   { \assumes (b ==>) \find (b | c ==>) \replacewith (true==>) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_or"};
  known_or_1_r   { \assumes (b ==>) \find (==> b | c) \replacewith (==>true) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_or"};

  known_or_2_l   { \assumes (==> b) \find (b | c ==>) \replacewith (c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_or"};
  known_or_2_r   { \assumes (==> b) \find (==> b | c) \replacewith (==>c) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_or"};

  known_or_3_l   { \assumes (b ==>) \find (c | b ==>) \replacewith (true==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_or"};
  known_or_3_r   { \assumes (b ==>) \find (==> c | b) \replacewith (==>true) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_or"};

  known_or_4_l   { \assumes (==> b) \find (c | b ==>) \replacewith (c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_or"};
  known_or_4_r   { \assumes (==> b) \find (==> c | b) \replacewith (==>c) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_or"};

  known_eq_1_l   { \assumes (b ==>) \find (b <-> c ==>) \replacewith (c==>) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_eq"};
  known_eq_1_r   { \assumes (b ==>) \find (==> b <-> c) \replacewith (==>c) 
			      \heuristics(simplify) \noninteractive 
                              \displayname "known_eq"};
  known_eq_2_l   { \assumes (==> b) \find (b <-> c ==>) \replacewith (! c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_eq"};
  known_eq_2_r   { \assumes (==> b) \find (==> b <-> c) \replacewith (==>! c) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_eq"};
  known_eq_3_l   { \assumes (b ==>) \find (c <-> b ==>) \replacewith (c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_eq"};
  known_eq_3_r   { \assumes (b ==>) \find (==> c <-> b) \replacewith (==>c) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_eq"};
  known_eq_4_l   { \assumes (==> b) \find (c <-> b ==>) \replacewith (!c==>) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_eq"};
  known_eq_4_r   { \assumes (==> b) \find (==> c <-> b) \replacewith (==>!c) 
			      \heuristics(simplify) \noninteractive
                              \displayname "known_eq"};
*/

  // other
  cut { "CUT: #b TRUE":\add (b ==>); "CUT: #b FALSE":\add (==> b) };

  cut_direct_r { \find (==> b) \replacewith (==> b); \add (b ==>) };
  cut_direct_l { \find (b ==>) \replacewith (b ==>); \add (==> b) };

  // proofobl not parsed yet.
  // rule_cut { \addrules (rule); \add (==> proofobl(rule)) };

  hide_left  { \find (b ==>) \replacewith (==>)
               \addrules( insert_hidden { \add (b ==>) } ) };
  hide_right { \find (==> b) \replacewith (==>)
               \addrules( insert_hidden { \add (==> b) } ) };

  case_distinction_r { \find (==> b)
		       \addrules( to_true  { \find (==> b) 
					      \replacewith(==>true)  
					    \heuristics(simplify)
					    \noninteractive } );
                       \addrules( to_false { \find (==> b) 
					      \replacewith(==>false) 
					    \heuristics(simplify) 
					    \noninteractive } )
                       \displayname "case_distinction"
		     };

  case_distinction_l { \find (b ==>)
		       \addrules( to_true  { \find (b ==>) 
					      \replacewith(true ==>)  
					    \heuristics(simplify)
					    \noninteractive } );
                       \addrules( to_false { \find (b ==>) 
					     \replacewith(false ==>) 
					    \heuristics(simplify) 
					    \noninteractive } )
                       \displayname "case_distinction"
		     };

}
