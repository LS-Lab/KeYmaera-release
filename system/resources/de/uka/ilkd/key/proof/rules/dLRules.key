// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe Germany
//                           Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
// This file contains rules for handling hybrid programs


\include ruleSetsDeclarations;

\optionsDecl{
}

\schemaVariables {
  // non-trace modalities
  \modalOperator { diamond, box } #allmodal;
  \modalOperator { diamond } #dia;
  \modalOperator { box } #box;

  // mixed trace/non-trace modalities
  // all modalities including traces
  \modalOperator { diamond, box, throughout /*, finally*/} #allmodaltr;
  \modalOperator { diamond /*, finally*/} #diatr;
  \modalOperator { box, throughout } #boxtr;

  // only trace modalities
  // all trace modalities
  \modalOperator { throughout /*, finally*/ } #trace;
  \modalOperator { throughout } #boxtbox;

  \formula phi, psi, post, inv, target, gen;
  \term R trm;  
  \skolemTerm R sk;
  \variables R u;

  \term R q;
  \term R s, t1;
  \term[rigid] R sr, tr1;
  \variables R n;

  \formula b, c, d;
  \formula[rigid] br, cr;

  \program DLProgram #dl, #dl2;
  \program DLFormula #dlform;
  \program DiffSystemWithTopLevelOr #diffsystemWithOr;
  \program DLExpression #dle;
  \program DLVariable #dlvar;
  \program RandomAssign #rdm;
  \program DiffSystem #diffsystem;
  \program SimpleOrdinaryDiffSystem #simpleode;
  \program OrdinaryDiffSystem #ordinarydiffsystem;
  \program NotDNFDiffSystem #notDNFODE;
  \program DiffSystemWithDifferentialInequality #ineqDiffSystem;
  \program DLVariableDeclaration #decl;

}

\rules {
  subst_to_eq { \find ({\subst u; trm} target) \sameUpdateLevel
                \varcond (\new(sk, \dependingOn(trm)))
                \replacewith ({\subst u; sk} target)
                \add (sk = trm ==>)
                \heuristics (simplify) };

  apply_subst { \find ({\subst u; trm} phi)
                // it is enough to rebuild the same term, as substitutions
                // are automatically applied in this situation
                \replacewith ({\subst u; trm} phi)
                \heuristics (try_apply_subst) };

 eliminate_variable_decl {
 	\find(\modality{#allmodaltr}#decl\endmodality(post))
	\replacewith(post)
	\heuristics(simplify)
 };

 applyEq { 
	\assumes (s = t1 ==>) \find (s) 
	\sameUpdateLevel
	\replacewith ( t1 )
        \heuristics ( apply_equations )
	\displayname "applyEq"
	\oldname "apply_eq"
 };

 applyEqRigid { 
	\assumes (sr = tr1 ==>) \find (sr)
	\replacewith ( tr1)
        \heuristics ( apply_equations )
	\displayname "applyEq"
	\oldname "apply_eq_rigid"
 };

////////////////////////////////////////
//
// program rules
//
 
 if_then_else_right {
 	\find(==>\modality{#allmodaltr} if(#dlform) then #dl else #dl2 fi\endmodality(post))
	"#dlform": \replacewith(#dlform ==> \modality{#allmodaltr} #dl\endmodality(post)); 
	"! #dlform": \replacewith(! #dlform ==> \modality{#allmodaltr} #dl2\endmodality(post)) 
\heuristics(simplify_prog)

 };

 if_then_right {
 	\find(==>\modality{#allmodaltr} if(#dlform) then #dl fi\endmodality(post))
	"#dlform": \replacewith(#dlform ==> \modality{#allmodaltr} #dl\endmodality(post)); 
	"! #dlform": \replacewith(! #dlform ==> post) 
	\heuristics(simplify_prog)

 };

 if_then_else_left {
 	\find(\modality{#allmodaltr} if(#dlform) then #dl else #dl2 fi\endmodality(post) ==>)
	"#dlform": \replacewith(#dlform, \modality{#allmodaltr} #dl\endmodality(post) ==>); 
	"! #dlform": \replacewith(! #dlform, \modality{#allmodaltr} #dl2\endmodality(post) ==>) 
	\heuristics(simplify_prog)
 };

 if_then_left {
 	\find(\modality{#allmodaltr} if(#dlform) then #dl fi\endmodality(post) ==>)
	"#dlform": \replacewith(#dlform, \modality{#allmodaltr} #dl\endmodality(post) ==>); 
	"! #dlform": \replacewith(! #dlform, post ==>) 
	\heuristics(simplify_prog)

 };

 modality_split_left { 
 	\find (\modality{#allmodal}#dl;#dl2\endmodality(post) ==>) 
 	\replacewith(\modality{#allmodal}#dl\endmodality(\modality{#allmodal}#dl2\endmodality(post)) ==>) 
 	\heuristics(simplify_prog)
};

 modality_split_right { 
 	\find (==> \modality{#allmodal}#dl;#dl2\endmodality(post)) 
 	\replacewith(==>\modality{#allmodal}#dl\endmodality(\modality{#allmodal}#dl2\endmodality(post))) 
 	\heuristics(simplify_prog)
};

 through_split_right { 
 	\find (==>\modality{#boxtbox}#dl;#dl2\endmodality(post)) 
 	\replacewith(==> \modality{throughout}#dl\endmodality(post) & \modality{box}#dl\endmodality(\modality{throughout}#dl2\endmodality(post))) 
 	\heuristics(simplify_prog)
};

 through_split_left { 
 	\find (\modality{#boxtbox}#dl;#dl2\endmodality(post) ==>) 
 	\replacewith(\modality{throughout}#dl\endmodality(post) & \modality{box}#dl\endmodality(\modality{throughout}#dl2\endmodality(post)) ==>) 
 	\heuristics(simplify_prog)
};

/*diamond_quest { \find (\modality{#dia}?#dlform\endmodality(post)) \replacewith(#prog2logic(#dlform) & post) \heuristics(simplify_prog)};
box_quest { \find (\modality{#box}?#dlform\endmodality(post)) \replacewith(#prog2logic(#dlform) -> post) \heuristics(simplify_prog)};*/

diamond_quest_left { 
 	\find (\modality{#dia}?#dlform\endmodality(post) ==>) 
	\replacewith(#dlform, post ==>) 
	\heuristics(simplify_prog)
};

diamond_quest_right { 
 	\find (==>\modality{#dia}?#dlform\endmodality(post)) 
	\replacewith(==> #dlform & post) 
	\heuristics(simplify_prog)
};

box_quest_left { 
 	\find (\modality{#box}?#dlform\endmodality(post) ==>) 
	\replacewith(#dlform -> post ==>) 
	\heuristics(simplify_prog)
};

box_quest_right { 
 	\find (==>\modality{#box}?#dlform\endmodality(post)) 
	\replacewith(#dlform ==> post) 
	\heuristics(simplify_prog)
};

boxtbox_quest_right { 
 	\find (==>\modality{#boxtbox}?#dlform\endmodality(post)) 
	\replacewith(==>post) 
	\heuristics(simplify_prog)
};

boxtbox_quest_left { 
 	\find (\modality{#boxtbox}?#dlform\endmodality(post)==>) 
	\replacewith(post ==>) 
	\heuristics(simplify_prog)
};

box_choice_right { 
 	\find (==>\modality{#boxtr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#boxtr}#dl\endmodality(post));
	\replacewith(==>\modality{#boxtr}#dl2\endmodality(post)) 
	\heuristics(simplify_prog)
};

box_choice_left { 
 	\find (\modality{#boxtr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#boxtr}#dl\endmodality(post), \modality{#boxtr}#dl2\endmodality(post) ==>) 
	\heuristics(simplify_prog)
};

diamond_choice_right { 
 	\find (==>\modality{#diatr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#diatr}#dl\endmodality(post), \modality{#diatr}#dl2\endmodality(post)) 
	\heuristics(simplify_prog)
};

diamond_choice_left { 
 	\find (\modality{#diatr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#diatr}#dl\endmodality(post)==>);
	\replacewith(\modality{#diatr}#dl2\endmodality(post)==>) 
	\heuristics(simplify_prog)
};
 
 // loop handling
 /*
 // These rules do not work, as KeY cannot reintroduce the *.
 diamond_unwind { 
 	\find (\modality{#dia}#dl* \endmodality(post)) 
	\replacewith(post | \modality{#dia}#dl\endmodality(\modality{#dia}(#dl)*\endmodality(post))) 
};
 box_unwind { 
 	\find (\modality{#box}#dl* \endmodality(post)) 
	\replacewith(post & \modality{#box}#dl\endmodality(\modality{#box}(#dl)*\endmodality(post)))
};
*/

loop_unwind_box { 
	\find (\modality{#box}#dl* \endmodality(post)) 
	\replacewith(post & (#dlunwind(\modality{box}#dl\endmodality(post))))
};

loop_unwind_dia { 
	\find (\modality{#dia}#dl* \endmodality(post)) 
	\replacewith(post | (#dlunwind(\modality{#dia}#dl\endmodality(post))))
};

loop_unwind_trace { 
	\find (\modality{#trace}#dl* \endmodality(post)) 
	\replacewith(#dlunwind(\modality{#trace}#dl\endmodality(post)))
};

//@todo add loop_inv_boxtbox trace versions for loops


 loop_inv_box_quan { \find (==> \[#dl*\]post) 
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Use Case":
          \replacewith (==> #dlUniversalClosure(\[#dl\]true, inv -> post, false));
    "Body Preserves Invariant":
          \replacewith (==>  #dlUniversalClosure(\[#dl\]true, (inv -> \[#dl\]inv), true))
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "loop_invariant_quan"}; 

 /* this rule may lead to unsound bahavior in conjunction with existential quantifiers
 
 loop_inv_box { \find (==> \[#dl*\]post) 
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Use Case":
          \replacewith (==> #dlintroNewAnonUpdate(\[#dl\]true, inv -> post));
    "Body Preserves Invariant":
          \replacewith (==>  #dlintroNewAnonUpdate(\[#dl\]true, (inv -> \[#dl\]inv)))
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "loop_invariant"};
 */
          
   loop_var_dia { \find (==> \<#dl*\>post)
    /* TODO this should be \varcond(\notFreeIn(n, \<#dl*\>post)) for soundness */
    \varcond(\notFreeIn(n, post))
    "Variant Satisfiable":
          \replacewith (==> \exists n; inv );
    "Use Case":
          \replacewith (==> #dlUniversalClosure(\<#dl\>true, (\exists n; (inv & n <= 0)) -> post, false));
    "Variant Decreases":
          \replacewith (==>  #dlUniversalClosure(\<#dl\>true, \forall n; (n>0 & inv -> \<#dl\> {\subst n; n-1}inv), true))
          \heuristics (loop_variant)
          \displayname "loop_variant"}; 
           

 generalisation { \find (==> \modality{#allmodal}#dl\endmodality(post))
    "Generalisation Holds":
          \replacewith (==> \modality{#allmodal}#dl\endmodality(gen) );
    "Generalisation Strong Enough":
          \replacewith (==>  #dlUniversalClosure(\modality{#allmodal}#dl\endmodality(post), (gen -> post), true))
 };
 // special case of generalisation
 seq_comp_generalisation { \find (==> \modality{#allmodal}#dl;#dl2\endmodality(post))
    "Generalisation Holds":
          \replacewith (==> \modality{#allmodal}#dl\endmodality(gen) );
    "Generalisation Strong Enough":
          \replacewith (==>  #dlUniversalClosure(\modality{#allmodal}#dl\endmodality(gen), (gen -> \modality{#allmodal}#dl2\endmodality(post)), true))
          \heuristics (split_gen)
          \displayname "sequential generalisation"
 }; 

 ODEDNF_left { 
 	\find (\modality{#allmodal}#notDNFODE \endmodality(post) ==>) 
	\replacewith(#DLDNF(\modality{#allmodal}#notDNFODE\endmodality(post)) ==>)  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "ODE to DNF"
 };

 ODEDNF_right { 
 	\find (==>\modality{#allmodal}#notDNFODE \endmodality(post)) 
	\replacewith(==>#DLDNF(\modality{#allmodal}#notDNFODE\endmodality(post)))  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "ODE to DNF"
 };

 ODEINEQ_left { 
 	\find (\modality{#allmodal}#ineqDiffSystem \endmodality(post) ==>) 
	\replacewith(#DLDiffInequalityRewrite(\modality{#allmodal}#ineqDiffSystem\endmodality(post)) ==>)  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "Rewrite Ineq in ODE"
 };

 ODEINEQ_right { 
 	\find (==>\modality{#allmodal}#ineqDiffSystem \endmodality(post)) 
	\replacewith(==>#DLDiffInequalityRewrite(\modality{#allmodal}#ineqDiffSystem\endmodality(post)))  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "Rewrite Ineq in ODE"
 };

 ODEChoice_left { 
 	\find (\modality{#allmodal}#diffsystemWithOr\endmodality(post) ==>) 
	\replacewith(#DLChoiceUnwind(\modality{#allmodal}#diffsystemWithOr\endmodality(post)) ==>)  
	\heuristics(diff_rule,diff_normalize_choice)
        \displayname "ODE Split"
 };

 ODEChoice_right { 
 	\find (==> \modality{#allmodal}#diffsystemWithOr\endmodality(post) )
	\replacewith(==> #DLChoiceUnwind(\modality{#allmodal}#diffsystemWithOr\endmodality(post)))  
	\heuristics(diff_rule,diff_normalize_choice)
        \displayname "ODE Split"
 };
 
 ODESolve_left { 
 	\find (\modality{#allmodal}#simpleode \endmodality(post) ==>) 
	\replacewith(#ODESolve(\modality{#allmodal}#simpleode\endmodality(post)) ==>)  
	\heuristics(diff_solve,diff_rule)
        \displayname "ODESolve"
 };

 ODESolve_right { 
 	\find (==>\modality{#allmodal}#simpleode \endmodality(post)) 
	\replacewith(==>#ODESolve(\modality{#allmodal}#simpleode\endmodality(post)))  
	\heuristics(diff_solve,diff_rule)
        \displayname "ODESolve"
 };

 diff_boxtbox_left { 
 	\find (\modality{#boxtbox}#diffsystem \endmodality(post) ==>) 
	\replacewith(\modality{box}#diffsystem \endmodality(post) ==>)  
	\heuristics(simplify_prog)
 };

 diff_boxtbox_right { 
 	\find (==>\modality{#boxtbox}#diffsystem \endmodality(post)) 
	\replacewith(==>\modality{box}#diffsystem \endmodality(post))  
	\heuristics(simplify_prog)
 };

 
 assignment_to_update_left {
 	\find (\modality{#allmodal}#dlvar := #dle \endmodality(post) ==>) 
	\replacewith(({#dlvar := #dle} post) ==>) 
	\heuristics(simplify_prog)
 };

 assignment_to_update_right {
 	\find (==>\modality{#allmodal}#dlvar := #dle \endmodality(post)) 
	\replacewith(==>({#dlvar := #dle} post)) 
	\heuristics(simplify_prog)
 };

 assignment_boxtbox_left {
     \find (\modality{#boxtbox}#dlvar := #dle \endmodality(post) ==>)
     \replacewith(post & ({#dlvar := #dle}(post)) ==>)
     \heuristics(simplify_prog)
 };

 assignment_boxtbox_right {
     \find (==>\modality{#boxtbox}#dlvar := #dle \endmodality(post))
     \replacewith(==> post & ({#dlvar := #dle}(post)))
     \heuristics(simplify_prog)
 };

random_ass_box_left {
	\find (\modality{#box}#rdm\endmodality(post) ==>)  
	\replacewith(#randomass(\modality{#box}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
};

random_ass_box_right {
	\find (==>\modality{#box}#rdm\endmodality(post))  
	\replacewith(==>#randomass(\modality{#box}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
};

random_ass_boxtbox_left { 
	\find (\modality{#boxtbox}#rdm\endmodality(post)==>)
	\replacewith(post & (\modality{box}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
};

random_ass_boxtbox_right { 
	\find (==>\modality{#boxtbox}#rdm\endmodality(post))  
	\replacewith(==>post & (\modality{box}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
};

random_ass_dia_left { 
	\find (\modality{#dia}#rdm\endmodality(post)==>)  
	\replacewith(#randomass(\modality{#dia}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
};

random_ass_dia_right { 
	\find (==>\modality{#dia}#rdm\endmodality(post))  
	\replacewith(==>#randomass(\modality{#dia}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
};


////////////////////////////////////////
//
// Math Predicate Rules
//
   simplify_form {\find (phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#simplify(phi, true)) 
         \displayname "simplify"};

   simplify_form_right {\find (==> phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (==> #simplify(phi, true)) 
		 \heuristics(mathematica_simplify)
         \displayname "simplify"};

   simplify_form_left {\find (phi ==>) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#simplify(phi, true) ==>) 
		 \heuristics(mathematica_simplify)
         \displayname "simplify"};

   simplify_form_ass_right {
   \assumes( post ==>)
   \find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith ( ==> #simplify(phi, post)) 
         \displayname "simplify_ass_from_left"};

   simplify_form_not_ass {
   \assumes( ==> post)
   \find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith ( ==> #simplify(phi, ! post)) 
         \displayname "simplify_ass_from_right"};

   simplify_form_ass_left {
   \assumes( post ==> )
   \find ( phi ==>)   
   		\varcond( \isFirstOrderFormula(phi))
      \replacewith ( #simplify(phi, post) ==> ) 
         \displayname "simplify_ass_from_left"};

   full_simplify_form {\find (phi)  
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith (#fullsimplify(phi)) 
         \displayname "full_simplify"};

   reduce_form {\find (phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith (#reduce(phi)) 
         \displayname "reduce"};

   reduce_form_right {\find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith (==> #reduce(phi)) 
	  	\heuristics(mathematica_reduce)
         \displayname "reduce"};

   reduce_form_left {\find (phi ==>)  
   	\varcond( \isFirstOrderFormula(phi))
       \replacewith (#reduce(phi) ==>) 
	  	\heuristics(mathematica_reduce)
         \displayname "reduce"};
	
////////////////////////////////////////
//
// Rules for handling quantifiers
//
   
  // Gamma rules

  all_left { 
  	\find (\forall u; b ==>) 
  	\replacewith ({\subst u; q}(b) ==>) 
  	\heuristics(gamma) 
  };

  ex_right { \find (==> \exists u; b)
             \replacewith (==> {\subst u; q}(b))
  	     \heuristics(gamma) };
  	     
  /*all_left_hide { \find (\forall u; b ==>) \replacewith ({\subst u; q}(b) ==>)
		    \addrules ( insert_hidden { \add (\forall u; b ==>) } )
                    \heuristics(gamma_destructive) };
  ex_right_hide { \find (==> \exists u; b) \replacewith (==> {\subst u; q}(b))
		    \addrules ( insert_hidden { \add (==> \exists u; b) } )
                    \heuristics(gamma_destructive) }; */
   
  // delta rules
  all_right { \find (==> \forall u; b) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith (==> {\subst u; sk}b) \heuristics (delta) };
  ex_left { \find (\exists u; b ==>) \varcond ( \new(sk, \dependingOn(b)) )
		\replacewith ({\subst u; sk}b ==>) \heuristics (delta) };

////////////////////////////////////////
//
// Propositional Rules
//

  // closing goals
  close_goal       { \assumes (b ==>) \find (==> b) \closegoal 
			    \heuristics(closure) };
  close_goal_antec { \assumes (==> b) \find (b ==>) \closegoal };
  close_by_false   { \find (false ==>) \closegoal \heuristics(closure) };
  close_by_true    { \find (==> true) \closegoal \heuristics(closure) };
  

  // simplify rules for "ReplaceKnownStrategy"
  replace_known_left  { \assumes ( b ==> ) \find ( b ) \sameUpdateLevel \replacewith ( true )
			   \heuristics(replace_known) \noninteractive };
  replace_known_right { \assumes ( ==> b ) \find ( b ) \sameUpdateLevel \replacewith ( false )
			   \heuristics(replace_known) \noninteractive };


  // junctor rules
  true_left    { \find (true ==>) \replacewith(==>) \heuristics(concrete) };
  false_right  { \find (==> false) \replacewith(==>) \heuristics(concrete) };

  not_left  { \find (! b ==>) \replacewith(==> b) \heuristics(alpha) };
  not_right { \find (==> ! b) \replacewith(b ==>) \heuristics(alpha) };

  imp_left  { \find (b -> c ==>) 
		\replacewith(==> b); 
                \replacewith(c ==>)
	      \heuristics(split,beta) };
  imp_right { \find (==> b -> c) \replacewith(b ==> c) 
		\heuristics(alpha) };

  and_left  { \find (b & c ==>) \replacewith(b, c ==>) \heuristics(alpha) };
  and_right { \find (==> b & c) \replacewith(==> b); \replacewith(==> c) 
                    \heuristics(split,beta) };
  or_left   { \find (b | c ==>) 
              "#b":\replacewith(b ==>); "#c":\replacewith(c ==>)
              \heuristics(split,beta) };
  or_right  { \find (==> b | c) \replacewith(==> b, c) \heuristics(alpha) };

//  equiv_left   { \find (b <-> c ==>) 
//		      \replacewith(b -> c, c -> b ==>)
//                    \heuristics(alpha_concrete) };

  equiv_left   { \find (b <-> c ==>) 
		      \replacewith(b, c ==>); 
                      \replacewith(==> b, c)
                    \heuristics(split,beta) };
  
//  equiv_right  { \find (==> b <-> c) 
//		      \replacewith(==> b & c, !b & !c)
//                    \heuristics(alpha_concrete) };

  equiv_right  { \find (==> b <-> c) 
		    "Case ->": \replacewith(b ==> c);
                    "Case <-": \replacewith(c ==> b)
                    \heuristics(split,beta) };

  /* These `recursive' rules are commented out, because this 
     keyword is not yet supported.
  imp_left_rec { \find (b -> c ==>)  \recursive 
		   \replacewith(==> b); 
                   \replacewith(c ==>) };
  and_right_rec { \find (==> b & c)  \recursive 
		    \replacewith(==> b); 
                    \replacewith(==> c) };
  or_left_rec { \find (b | c ==>)  \recursive
		  \replacewith(b ==>); 
                  \replacewith(c ==>) };
  */
  
  split_or_strong { \find (b | c ==>) 
		      \replacewith (b ==>); 
                      \replacewith(c ==> b) };

///////////////////////////////////////////////////////////////////////////////
// 8 beta rules that perform an implicit cut, i.e. that introduce lemmas.
// The treated cases occur frequently when splitting programs with if-branches.
// These rules are given slightly higher priority than the usual beta rules in
// strategy "Simple JavaCardLD"

  imp_left_lemma { \assumes (!b -> d ==>) \find (b -> c ==>)
                   \replacewith (==> b);
                   \replacewith (b, c ==>)
                   \heuristics(beta,beta_lemma) };

  imp_left_lemma_2 { \assumes (==> !b & d) \find (b -> c ==>)
                     \replacewith (==> b);
                     \replacewith (b, c ==>)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  imp_left_lemma_3 { \assumes (b -> d ==>) \find (!b -> c ==>)
                     \replacewith (b ==>);
                     \replacewith (c ==> b)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  imp_left_lemma_4 { \assumes (==> b & d) \find (!b -> c ==>)
                     \replacewith (b ==>);
                     \replacewith (c ==> b)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  and_right_lemma { \assumes (!b -> d ==>) \find (==> b & c)
                    \replacewith (==> b);
                    \replacewith (b ==> c)
                    \heuristics(beta,beta_lemma) };

  and_right_lemma_2 { \assumes (==> !b & d) \find (==> b & c)
                      \replacewith (==> b);
                      \replacewith (b ==> c)
                      \heuristics(beta,beta_lemma)
                      \displayname "and_right_lemma" };

  and_right_lemma_3 { \assumes (b -> d ==>) \find (==> !b & c)
                    \replacewith (b ==>);
                    \replacewith (==> b, c)
                    \heuristics(beta,beta_lemma) };

  and_right_lemma_4 { \assumes (==> b & d) \find (==> !b & c)
                      \replacewith (b ==>);
                      \replacewith (==> b, c)
                      \heuristics(beta,beta_lemma)
                      \displayname "and_right_lemma" };

///////////////////////////////////////////////////////////////////////////////

  shift_paren_and { \find (b & (c & d)) \replacewith ((b & c) & d)
                        \heuristics(simplify) };
  shift_paren_or  { \find (b | (c | d)) \replacewith ((b | c) | d)
                        \heuristics(simplify) };
  commute_and { \find (b & c) \replacewith (c & b) };
  commute_or  { \find (b | c) \replacewith (c | b) };
  rotate_and { \find (b & (c & d)) \replacewith (c & (b & d)) };
  rotate_or  { \find (b | (c | d)) \replacewith (c | (b | d)) };
  
  // equivalence replacement
  insert_eqv_once_lr { \find (br <-> cr ==>) 
			\addrules( insert_eqv{ \find (br) \replacewith (cr)} )
		       \heuristics(simplify) \noninteractive };
  insert_eqv_once_rl { \find (br <-> cr ==>) 
			 \addrules( insert_eqv{ \find (cr) \replacewith (br)} )
                       \heuristics(simplify) \noninteractive };

  insert_eqv_lr { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (br) \replacewith (cr) 
					  \heuristics(simplify) } ) };
  insert_eqv_rl { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (cr) \replacewith (br) 
					  \heuristics(simplify) } ) };

  // simplification
  double_not { \find ( ! ( ! b)) \replacewith (b) \heuristics(concrete) };

  concrete_not_1  { \find (! true) \replacewith (false) \heuristics(concrete) };
  concrete_not_2  { \find (! false) \replacewith (true) \heuristics(concrete) };

  concrete_impl_1 { \find (true -> b) \replacewith (b) \heuristics(concrete) };
  concrete_impl_2 { \find (false -> b) \replacewith (true) \heuristics(concrete) };
  concrete_impl_3 { \find (b -> false) \replacewith (! b) \heuristics(concrete) };
  concrete_impl_4 { \find (b -> true) \replacewith (true) \heuristics(concrete) };

  concrete_and_1  { \find (true & b) \replacewith (b) \heuristics(concrete) };
  concrete_and_2  { \find (false & b) \replacewith (false) \heuristics(concrete) };
  concrete_and_3  { \find (b & true) \replacewith (b) \heuristics(concrete) };
  concrete_and_4  { \find (b & false) \replacewith (false) \heuristics(concrete) };

  concrete_or_1   { \find (true | b) \replacewith (true) \heuristics(concrete) };
  concrete_or_2   { \find (false | b) \replacewith (b) \heuristics(concrete) };
  concrete_or_3   { \find (b | true) \replacewith (true) \heuristics(concrete) };
  concrete_or_4   { \find (b | false) \replacewith (b) \heuristics(concrete) };
  
  concrete_eq_1   { \find (true <-> b) \replacewith (b) \heuristics(concrete) };
  concrete_eq_2   { \find (false <-> b) \replacewith (! b) \heuristics(concrete) };
  concrete_eq_3   { \find (b <-> true) \replacewith (b) \heuristics(concrete) };
  concrete_eq_4   { \find (b <-> false) \replacewith (! b) \heuristics(concrete) };
  


  // other
  cut { "CUT: #b":\add (b ==>); "CUT: ! #b":\add (==> b) };

  cut_direct_r { \find (==> b) \replacewith (==> b); \add (b ==>) };
  cut_direct_l { \find (b ==>) \replacewith (b ==>); \add (==> b) };

  // proofobl not parsed yet.
  // rule_cut { \addrules (rule); \add (==> proofobl(rule)) };

  hide_left  { \find (b ==>) \replacewith (==>)
               \addrules( insert_hidden { \add (b ==>) } ) 
               //\heuristics(hiding)
               };
  hide_right { \find (==> b) \replacewith (==>)
               \addrules( insert_hidden { \add (==> b) } ) 
               //\heuristics(hiding)
               };

  case_distinction_r { \find (==> b)
		       \addrules( to_true  { \find (==> b) 
					      \replacewith(==>true)  
					    \heuristics(simplify)
					    \noninteractive } );
                       \addrules( to_false { \find (==> b) 
					      \replacewith(==>false) 
					    \heuristics(simplify) 
					    \noninteractive } )
                       \displayname "case_distinction"
		     };

  case_distinction_l { \find (b ==>)
		       \addrules( to_true  { \find (b ==>) 
					      \replacewith(true ==>)  
					    \heuristics(simplify)
					    \noninteractive } );
                       \addrules( to_false { \find (b ==>) 
					     \replacewith(false ==>) 
					    \heuristics(simplify) 
					    \noninteractive } )
                       \displayname "case_distinction"
		     };

}
