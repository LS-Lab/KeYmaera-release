// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2005 Universitaet Karlsruhe Germany
//                           Universitaet Koblenz-Landau, Germany
//                         and Chalmers University of Technology, Sweden
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
// This file contains rules for handling hybrid programs


\include ruleSetsDeclarations;

\optionsDecl{
}

\sorts {
\generic C;
\generic C2;
}

\functions {
	\external R Abs(R);	
	\external R Min(R,R);
	\external R Max(R,R);
}

\schemaVariables {
  // non-trace modalities
  \modalOperator { diamond, box } #allmodal;
  \modalOperator { diamond } #dia;
  \modalOperator { box } #box;

  // mixed trace/non-trace modalities
  // all modalities including traces
  \modalOperator { diamond, box, throughout /*, finally*/} #allmodaltr;
  \modalOperator { diamond /*, finally*/} #diatr;
  \modalOperator { box, throughout } #boxtr;

  // only trace modalities
  // all trace modalities
  \modalOperator { throughout /*, finally*/ } #trace;
  \modalOperator { throughout } #boxtbox;

  \formula phi, psi, post, inv, target, gen;
  \term R trm;  
  \term R trm2;
  \skolemTerm R sk;
  \variables R u;

  \term C2 trmC2;  
  \term C trmC;  
  \skolemTerm C skC;
  \variables C uC;
  \term C qC;
  \term C tC;

  \term R q;
  \term R s, t1;
  \term C sC, t1C;
  \term[rigid] R sr, tr1;
  \variables R n,m;

  \formula b, c, d;
  \formula[rigid] br, cr;

  \program DLProgram #dl, #dl2;
  \program DLFormula #dlform;
  \program DiffSystemWithTopLevelOr #diffsystemWithOr;
  \program DLExpression #dle, #rate, #constant, #linear, #dle2;
  \program DLVariable #dlvar;
  \program RandomAssign #rdm;
  \program DiffSystem #diffsystem;
  \program SimpleOrdinaryDiffSystem #simpleode;
  \program QuantifiedSimpleOrdinaryDiffSystem #qsimpleode;
  \program OrdinaryDiffSystem #ordinarydiffsystem;
  \program NotDNFDiffSystem #notDNFODE;
  \program DiffSystemWithDifferentialInequality #ineqDiffSystem;
  \program DLVariableDeclaration #decl;

}

\rules {
  subst_to_eq { \find ({\subst u; trm} target) \sameUpdateLevel
                \varcond (\new(sk, \dependingOn(trm)))
                \replacewith ({\subst u; sk} target)
                \add (sk = trm ==>)
                \heuristics (simplify) };

  apply_subst { \find ({\subst u; trm} phi)
                // it is enough to rebuild the same term, as substitutions
                // are automatically applied in this situation
                \replacewith ({\subst u; trm} phi)
                \heuristics (try_apply_subst) };

  apply_subst_gen { \find ({\subst uC; trmC} trmC2)
                // it is enough to rebuild the same term, as substitutions
                // are automatically applied in this situation
                \replacewith ({\subst uC; trmC} trmC2)
                \heuristics (try_apply_subst) };

  skolemize {
  \find(trm)
  \sameUpdateLevel
  \varcond(\new(sk, \dependingOn(trm)))
  \replacewith(sk)
  \add(sk = trm ==>)
  \displayname "abbreviate"
  };

  intro_aux {
  \find (post)
  \varcond(\new(#dlvar, R))
  \replacewith(\[ #dlvar := #dle \] post)
  \addprogvars(#dlvar)
  \heuristics (auxilaries)
  \displayname "auxiliary variable"
  };

  diff_aux {
  \find(\modality{#allmodaltr}#diffsystem\endmodality(phi))
  \varcond(\new(#dlvar, R), \notFreeIn(n, phi))
  "Initially Valid": \replacewith(phi);
  "Auxiliary Equivalent": \replacewith(#dlUniversalClosure(\[#diffsystem\]true, phi <-> (\exists n; psi), false));
  "Well-defined": \replacewith(\[#diffsystem\](#defined(\[ ?#linear = 0\]true) & #defined(\[ ?#constant = 0\]true)));
  "Augmented Auxiliary": \replacewith((\forall n; (#dlvar = n -> psi)) -> #diffadd(\modality{#allmodaltr}#diffsystem\endmodality((\forall n; (#dlvar = n -> psi))), \[ { #dlvar' = #dlvar * #linear + #constant } \] true))
  \addprogvars(#dlvar)
  \heuristics (auxilaries)
  \onlyRigidFunctions
  \displayname "DA differential auxiliaries"
  };

  diff_aux_fresh {
  \find(\modality{#allmodaltr}#diffsystem\endmodality(phi))
  \varcond(\new(#dlvar, R), \notFreeIn(n, phi))
  "Initially Valid": \replacewith(phi);
  "Auxiliary Equivalent": \addfreshgoal(phi <-> (\exists n; psi));
  "Well-defined": \replacewith(\[#diffsystem\](#defined(\[ ?#linear = 0\]true) & #defined(\[ ?#constant = 0\]true)));
  "Augmented Auxiliary": \replacewith((\forall n; (#dlvar = n -> psi)) -> #diffadd(\modality{#allmodaltr}#diffsystem\endmodality((\forall n; (#dlvar = n -> psi))), \[ { #dlvar' = #dlvar * #linear + #constant } \] true))
  \addprogvars(#dlvar)
  \heuristics (auxilaries)
  \displayname "DA differential auxiliaries (drop context)"
  };

  intro_aux_diff {
  \find(\modality{#allmodaltr}#diffsystem\endmodality(post))
  \varcond(\new(#dlvar, R))
  "Well-defined": \replacewith(\[#diffsystem\](#defined(\[ ?#rate = 0 \]true)));
  "Augmented Rate": \replacewith(\modality{#allmodaltr} #dlvar := #dle\endmodality(#diffadd(\modality{#allmodaltr}#diffsystem\endmodality(post), \[ { #dlvar' = #rate } \] true)))
  \addprogvars(#dlvar)
  \heuristics (auxilaries)
  \displayname "DA differential auxiliaries (simple rate recall)"
  };

  /* 
  // The rule is unsound in this form, but we need someting similary to handle x'=-x
  intro_aux_diff_test {
  \find(\modality{#allmodaltr}#diffsystem\endmodality(post))
  \varcond(\new(#dlvar, R))
  \replacewith(\modality{#allmodaltr} #dlvar := *; ?#dlform\endmodality(#diffadd(\modality{#allmodaltr}#diffsystem\endmodality(post), \[ { #dlvar' = #rate } \] true)))
  \addprogvars(#dlvar)
  \heuristics (auxilaries)
  };*/

 eliminate_variable_decl {
 	\find(\modality{#allmodaltr}#decl\endmodality(post))
	\replacewith(post)
	\heuristics(simplify)
	\displayname "declare variable"
 };

 applyEq { 
	\assumes (sC = t1C ==>) \find (sC) 
	\sameUpdateLevel
	\replacewith ( t1C )
        \heuristics ( apply_equations )
	\displayname "apply equation"
	\oldname "apply_eq"
 };

 applyEq_sym { 
	\assumes (t1C = sC ==>) \find (sC) 
	\sameUpdateLevel
	\replacewith ( t1C )
	\heuristics (apply_equations_sym)
	\displayname "apply equation"
	\oldname "apply_eq"
 };

 applyEqRigid { 
	\assumes (sr = tr1 ==>) \find (sr)
	\replacewith ( tr1)
        \heuristics ( apply_equations )
	\displayname "apply equation"
	\oldname "apply_eq_rigid"
 };

////////////////////////////////////////
//
// program rules
//
 
 if_then_else_right {
 	\find(==>\modality{#allmodaltr} if(#dlform) then #dl else #dl2 fi\endmodality(post))
	"#dlform": \replacewith(#dlform ==> \modality{#allmodaltr} #dl\endmodality(post)); 
	"! #dlform": \replacewith(! #dlform ==> \modality{#allmodaltr} #dl2\endmodality(post)) 
\heuristics(simplify_prog)
    \displayname "if-then-else right"

 };

 if_then_right {
 	\find(==>\modality{#allmodaltr} if(#dlform) then #dl fi\endmodality(post))
	"#dlform": \replacewith(#dlform ==> \modality{#allmodaltr} #dl\endmodality(post)); 
	"! #dlform": \replacewith(! #dlform ==> post) 
	\heuristics(simplify_prog)
    \displayname "if-then right"
 };

 if_then_else_left {
 	\find(\modality{#allmodaltr} if(#dlform) then #dl else #dl2 fi\endmodality(post) ==>)
	"#dlform": \replacewith(#dlform, \modality{#allmodaltr} #dl\endmodality(post) ==>); 
	"! #dlform": \replacewith(! #dlform, \modality{#allmodaltr} #dl2\endmodality(post) ==>) 
	\heuristics(simplify_prog)
	\displayname "if-then-else left"
 };

 if_then_left {
 	\find(\modality{#allmodaltr} if(#dlform) then #dl fi\endmodality(post) ==>)
	"#dlform": \replacewith(#dlform, \modality{#allmodaltr} #dl\endmodality(post) ==>); 
	"! #dlform": \replacewith(! #dlform, post ==>) 
	\heuristics(simplify_prog)
	\displayname "if-then left"
 };

 modality_split_left { 
 	\find (\modality{#allmodal}#dl;#dl2\endmodality(post) ==>) 
 	\replacewith(\modality{#allmodal}#dl\endmodality(\modality{#allmodal}#dl2\endmodality(post)) ==>) 
 	\heuristics(simplify_prog)
	\displayname "(;) compose"
};

 modality_split_right { 
 	\find (==> \modality{#allmodal}#dl;#dl2\endmodality(post)) 
 	\replacewith(==>\modality{#allmodal}#dl\endmodality(\modality{#allmodal}#dl2\endmodality(post))) 
 	\heuristics(simplify_prog)
	\displayname "(;) compose"
};

 through_split_right { 
 	\find (==>\modality{#boxtbox}#dl;#dl2\endmodality(post)) 
 	\replacewith(==> \modality{throughout}#dl\endmodality(post) & \modality{box}#dl\endmodality(\modality{throughout}#dl2\endmodality(post))) 
 	\heuristics(simplify_prog)
	\displayname "[;][] compose"
};

 through_split_left { 
 	\find (\modality{#boxtbox}#dl;#dl2\endmodality(post) ==>) 
 	\replacewith(\modality{throughout}#dl\endmodality(post) & \modality{box}#dl\endmodality(\modality{throughout}#dl2\endmodality(post)) ==>) 
 	\heuristics(simplify_prog)
	\displayname "[;][] compose"
};

/*diamond_quest { \find (\modality{#dia}?#dlform\endmodality(post)) \replacewith(#prog2logic(#dlform) & post) \heuristics(simplify_prog)};
box_quest { \find (\modality{#box}?#dlform\endmodality(post)) \replacewith(#prog2logic(#dlform) -> post) \heuristics(simplify_prog)};*/

diamond_quest_left { 
 	\find (\modality{#dia}?#dlform\endmodality(post) ==>) 
	\replacewith(#dlform, post ==>) 
	\heuristics(simplify_prog)
	\displayname "<?> test"
};

diamond_quest_right { 
 	\find (==>\modality{#dia}?#dlform\endmodality(post)) 
	\replacewith(==> #dlform & post) 
	\heuristics(simplify_prog)
	\displayname "<?> test"
};

box_quest_left { 
 	\find (\modality{#box}?#dlform\endmodality(post) ==>) 
	\replacewith(#dlform -> post ==>) 
	\heuristics(simplify_prog)
	\displayname "[?] test"
};

box_quest_right { 
 	\find (==>\modality{#box}?#dlform\endmodality(post)) 
	\replacewith(#dlform ==> post) 
	\heuristics(simplify_prog)
	\displayname "[?] test"
};

boxtbox_quest_right { 
 	\find (==>\modality{#boxtbox}?#dlform\endmodality(post)) 
	\replacewith(==>post) 
	\heuristics(simplify_prog)
	\displayname "[?][] test"
};

boxtbox_quest_left { 
 	\find (\modality{#boxtbox}?#dlform\endmodality(post)==>) 
	\replacewith(post ==>) 
	\heuristics(simplify_prog)
	\displayname "[?][] test"
};

box_choice_right { 
 	\find (==>\modality{#boxtr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#boxtr}#dl\endmodality(post));
	\replacewith(==>\modality{#boxtr}#dl2\endmodality(post)) 
	\displayname "[++] choice"
	\unicodename "<html><body>[&cup;] choice</body></html>"
	\noninteractive
};

box_choice_right_new {
 	\find (==>\modality{#boxtr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#boxtr}#dl\endmodality(post) & \modality{#boxtr}#dl2\endmodality(post))
	\heuristics(simplify_prog)
	\displayname "[++] choice"
	\unicodename "<html><body>[&cup;] choice</body></html>"
};

box_choice_left { 
 	\find (\modality{#boxtr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#boxtr}#dl\endmodality(post), \modality{#boxtr}#dl2\endmodality(post) ==>) 
	\displayname "[++] choice"
	\unicodename "<html><body>[&cup;] choice</body></html>"
	\noninteractive
};

box_choice_left_new { 
 	\find (\modality{#boxtr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#boxtr}#dl\endmodality(post) & \modality{#boxtr}#dl2\endmodality(post) ==>)
	\heuristics(simplify_prog)
	\displayname "[++] choice"
	\unicodename "<html><body>[&cup;] choice</body></html>"
};

diamond_choice_right { 
 	\find (==>\modality{#diatr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#diatr}#dl\endmodality(post), \modality{#diatr}#dl2\endmodality(post)) 
	\displayname "<++> choice"
	\unicodename "<html><body>&lt;&cup;&gt; choice</body></html>"
	\noninteractive
};

diamond_choice_left { 
 	\find (\modality{#diatr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#diatr}#dl\endmodality(post)==>);
	\replacewith(\modality{#diatr}#dl2\endmodality(post)==>) 
	\displayname "<++> choice"
	\unicodename "<html><body>&lt;&cup;&gt; choice</body></html>"
	\noninteractive
};

diamond_choice_left_new { 
 	\find (\modality{#diatr}#dl ++ #dl2 \endmodality(post) ==>) 
	\replacewith(\modality{#diatr}#dl\endmodality(post) | \modality{#diatr}#dl2\endmodality(post)==>)
	\heuristics(simplify_prog)
	\displayname "<++> choice"
	\unicodename "<html><body>&lt;&cup;&gt; choice</body></html>"
};

diamond_choice_right_new { 
 	\find (==>\modality{#diatr}#dl ++ #dl2 \endmodality(post)) 
	\replacewith(==>\modality{#diatr}#dl\endmodality(post) | \modality{#diatr}#dl2\endmodality(post))
	\heuristics(simplify_prog)
	\displayname "<++> choice"
	\unicodename "<html><body>&lt;&cup;&gt; choice</body></html>"
};

 
 // loop handling
 /*
 // These rules do not work, as KeY cannot reintroduce the *.
 diamond_unwind { 
 	\find (\modality{#dia}#dl* \endmodality(post)) 
	\replacewith(post | \modality{#dia}#dl\endmodality(\modality{#dia}(#dl)*\endmodality(post)))
	\displayname "<*n> unwind" 
};
 box_unwind { 
 	\find (\modality{#box}#dl* \endmodality(post)) 
	\replacewith(post & \modality{#box}#dl\endmodality(\modality{#box}(#dl)*\endmodality(post)))
};
*/

loop_unwind_box { 
	\find (\modality{#box}#dl* \endmodality(post)) 
	\replacewith(post & (\modality{box}#dl\endmodality(\modality{box}#dl*\endmodality(post))))
	\displayname "[*n] unwind"
};

loop_unwind_dia { 
	\find (\modality{#dia}#dl* \endmodality(post)) 
	\replacewith(post | (\modality{#dia}#dl\endmodality(\modality{#dia}#dl*\endmodality(post))))
	\displayname "<*n> unwind"
};

loop_unwind_trace { 
	\find (\modality{#trace}#dl* \endmodality(post)) 
	\replacewith(\modality{#trace}#dl\endmodality(\modality{#trace}#dl*\endmodality(post)))
	\displayname "[*n][] unwind"
};

 loop_inv_box_fresh { \find (==> \modality{#boxtr}#dl*\endmodality(post)) 
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Use Case":
          \addfreshgoal (==> inv -> post);
    "Body Preserves Invariant":
          \addfreshgoal (==> inv -> \modality{#boxtr}#dl\endmodality(inv))
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "ind loop invariant (global)"}; 

 loop_inv_box_quan { \find (==> \modality{#boxtr}#dl*\endmodality(post)) 
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Use Case":
          \replacewith (==> #dlUniversalClosure(\[#dl\]true, inv -> post, false));
    "Body Preserves Invariant":
          \replacewith (==>  #dlUniversalClosure(\[#dl\]true, (inv -> \modality{#boxtr}#dl\endmodality(inv)), true))
          \heuristics (loop_invariant, loop_invariant_proposal)
		  \onlyRigidFunctions
          \displayname "ind loop invariant"}; 

 /* this rule may lead to unsound behavior in conjunction with existential quantifiers
 
 loop_inv_box { \find (==> \[#dl*\]post) 
    "Invariant Initially Valid":
          \replacewith (==> inv );
    "Use Case":
          \replacewith (==> #dlintroNewAnonUpdate(\[#dl\]true, inv -> post));
    "Body Preserves Invariant":
          \replacewith (==>  #dlintroNewAnonUpdate(\[#dl\]true, (inv -> \[#dl\]inv)))
          \heuristics (loop_invariant, loop_invariant_proposal)
          \displayname "loop_invariant_"};
 */
          
   loop_var_dia { \find (==> \<#dl*\>post)
    /* TODO this should be \varcond(\notFreeIn(n, \<#dl*\>post)) for soundness */
    \varcond(\notFreeIn(n, post))
    "Variant Satisfiable":
          \replacewith (==> \exists n; inv );
    "Use Case":
          \replacewith (==> #dlUniversalClosure(\<#dl\>true, (\exists n; (inv & n <= 0)) -> post, false));
    "Variant Decreases":
          \replacewith (==>  #dlUniversalClosure(\<#dl\>true, \forall n; (n>0 & inv -> \<#dl\> {\subst n; n-1}inv), true))
          \heuristics (loop_variant)
		  \onlyRigidFunctions
          \displayname "con loop convergence"}; 

   loop_var_dia_fresh { \find (==> \<#dl*\>post)
    /* TODO this should be \varcond(\notFreeIn(n, \<#dl*\>post)) for soundness */
    \varcond(\notFreeIn(n, post))
    "Variant Satisfiable":
          \replacewith (==> \exists n; inv );
    "Use Case":
          \addfreshgoal (==> (\exists n; (inv & n <= 0)) -> post);
    "Variant Decreases":
          \addfreshgoal (==>  \forall n; (n>0 & inv -> \<#dl\> {\subst n; n-1}inv))
		  \onlyRigidFunctions
          \displayname "con loop convergence (global)"}; 

 box_and_right { \find (==> \modality{#boxtr}#dl\endmodality(phi&psi))
          \replacewith(==> \modality{#boxtr}#dl\endmodality(phi) & \modality{#boxtr}#dl\endmodality(psi))
          \displayname "[]& split box conjunction"
          \unicodename "<html><body>[]&and; split box conjunction</body></html>"
 };

 box_and_left { \find (\modality{#boxtr}#dl\endmodality(phi&psi) ==>)
          \replacewith(\modality{#boxtr}#dl\endmodality(phi) & \modality{#boxtr}#dl\endmodality(psi) ==>)
          \displayname "[]& split box conjunction"
          \unicodename "<html><body>[]&and; split box conjunction</body></html>"
 };
           
 generalisation { \find (==> \modality{#allmodal}#dl\endmodality(post))
    "Generalisation Holds":
          \replacewith (==> \modality{#allmodal}#dl\endmodality(gen) );
    "Generalisation Strong Enough":
          \replacewith (==>  #dlUniversalClosure(\[#dl\](post), (gen -> post), true))
		  \onlyRigidFunctions
          \displayname "[]gen generalization"
 };

 generalisation_fresh { \find (==> \modality{#allmodal}#dl\endmodality(post))
    "Generalisation Holds":
          \replacewith (==> \modality{#allmodal}#dl\endmodality(gen) );
    "Generalisation Strong Enough":
          \addfreshgoal (==> gen -> post)
          \displayname "[]gen generalization (global)"
 };
 // special case of generalisation
 seq_comp_generalisation { \find (==> \modality{#allmodal}#dl;#dl2\endmodality(post))
    "Generalisation Holds":
          \replacewith (==> \modality{#allmodal}#dl\endmodality(gen) );
    "Generalisation Strong Enough":
          \replacewith (==>  #dlUniversalClosure(\modality{#allmodal}#dl\endmodality(gen), (gen -> \modality{#allmodal}#dl2\endmodality(post)), true))
          \heuristics (split_gen)
		  \onlyRigidFunctions
		\displayname "[;]gen generalization (compose)"
 }; 

 seq_comp_generalisation_fresh { \find (==> \modality{#allmodal}#dl;#dl2\endmodality(post))
    "Generalisation Holds":
          \replacewith (==> \modality{#allmodal}#dl\endmodality(gen) );
    "Generalisation Strong Enough":
          \addfreshgoal (==> gen -> \modality{#allmodal}#dl2\endmodality(post))
          \heuristics (split_gen)
		\displayname "[;]gen generalization (compose, global)"
 }; 

 ODEDNF_left { 
 	\find (\modality{#allmodal}#notDNFODE \endmodality(post) ==>) 
	\replacewith(#DLDNF(\modality{#allmodal}#notDNFODE\endmodality(post)) ==>)  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "ODE to DNF"
 };

 ODEDNF_right { 
 	\find (==>\modality{#allmodal}#notDNFODE \endmodality(post)) 
	\replacewith(==>#DLDNF(\modality{#allmodal}#notDNFODE\endmodality(post)))  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "ODE to DNF"
 };

 ODEINEQ_left { 
 	\find (\modality{#allmodal}#ineqDiffSystem \endmodality(post) ==>) 
	\replacewith(#DLDiffInequalityRewrite(\modality{#allmodal}#ineqDiffSystem\endmodality(post)) ==>)  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "ODE differential inequality"
 };

 ODEINEQ_right { 
 	\find (==>\modality{#allmodal}#ineqDiffSystem \endmodality(post)) 
	\replacewith(==>#DLDiffInequalityRewrite(\modality{#allmodal}#ineqDiffSystem\endmodality(post)))  
	\heuristics(diff_rule,diff_normalize_dnf)
        \displayname "ODE differential inequality"
 };

 ODEChoice_left { 
 	\find (\modality{#allmodal}#diffsystemWithOr\endmodality(post) ==>) 
	\replacewith(#DLChoiceUnwind(\modality{#allmodal}#diffsystemWithOr\endmodality(post)) ==>)  
	\heuristics(diff_rule,diff_normalize_choice)
        \displayname "ODE or"
        \unicodename "<html><body>ODE &or;</body></html>"
 };

 ODEChoice_right { 
 	\find (==> \modality{#allmodal}#diffsystemWithOr\endmodality(post) )
	\replacewith(==> #DLChoiceUnwind(\modality{#allmodal}#diffsystemWithOr\endmodality(post)))  
	\heuristics(diff_rule,diff_normalize_choice)
        \displayname "ODE or"
        \unicodename "<html><body>ODE &or;</body></html>"
 };
 
 ODESolve_left { 
 	\find (\modality{#allmodal}#simpleode \endmodality(post) ==>) 
	\replacewith(#ODESolve(\modality{#allmodal}#simpleode\endmodality(post)) ==>)  
	\heuristics(diff_solve,diff_rule)
	\displayname "(') ODE solve"
 };

 ODESolve_right { 
 	\find (==>\modality{#allmodal}#simpleode \endmodality(post)) 
	\replacewith(==>#ODESolve(\modality{#allmodal}#simpleode\endmodality(post)))  
	\heuristics(diff_solve,diff_rule)
        \displayname "(') ODE solve"
 };

 QODESolve_left { 
 	\find (\modality{#allmodal}#qsimpleode \endmodality(post) ==>) 
	\replacewith(#QODESolve(\modality{#allmodal}#qsimpleode\endmodality(post)) ==>)  
//	\heuristics(diff_solve,diff_rule)
        \displayname "(') QODE solve"
 };

 QODESolve_right { 
 	\find (==>\modality{#allmodal}#qsimpleode \endmodality(post)) 
	\replacewith(==>#QODESolve(\modality{#allmodal}#qsimpleode\endmodality(post)))  
//	\heuristics(diff_solve,diff_rule)
        \displayname "(') QODE solve"
 };

 diff_boxtbox_left { 
 	\find (\modality{#boxtbox}#diffsystem \endmodality(post) ==>) 
	\replacewith(\modality{box}#diffsystem \endmodality(post) ==>)  
	\heuristics(simplify_prog)
    \displayname "['][]"
 };

 diff_boxtbox_right { 
 	\find (==>\modality{#boxtbox}#diffsystem \endmodality(post)) 
	\replacewith(==>\modality{box}#diffsystem \endmodality(post))  
	\heuristics(simplify_prog)
    \displayname "['][]"
 };

 
 assignment_to_update_left_quan {
 	\find (\modality{#allmodal}\forall #decl; #dle := #dle2 \endmodality(post) ==>) 
	\replacewith((#quanupdate(\modality{#allmodal}\forall #decl; #dle := #dle2 \endmodality(post))) ==>) 
	\heuristics(simplify_prog)
    \displayname ":= assign"
 };

 assignment_to_update_left {
 	\find (\modality{#allmodal}#dle := #dle2 \endmodality(post) ==>) 
	\replacewith(({#dle := #dle2} post) ==>) 
	\heuristics(simplify_prog)
    \displayname ":= assign"
 };

 assignment_to_update_right_quan {
 	\find (==>\modality{#allmodal}\forall #decl; #dle := #dle2 \endmodality(post)) 
	\replacewith(==>(#quanupdate(\modality{#allmodal}\forall #decl; #dle := #dle2 \endmodality(post)))) 
	\heuristics(simplify_prog)
    \displayname ":= assign"
 };

 assignment_to_update_right {
 	\find (==>\modality{#allmodal}#dle := #dle2 \endmodality(post)) 
	\replacewith(==>({#dle := #dle2} post)) 
	\heuristics(simplify_prog)
    \displayname ":= assign"
 };

 assignment_boxtbox_left {
     \find (\modality{#boxtbox}#dlvar := #dle \endmodality(post) ==>)
     \replacewith(post & ({#dlvar := #dle}(post)) ==>)
     \heuristics(simplify_prog)
     \displayname "[:=][] assign"
 };

 assignment_boxtbox_right {
     \find (==>\modality{#boxtbox}#dlvar := #dle \endmodality(post))
     \replacewith(==> post & ({#dlvar := #dle}(post)))
     \heuristics(simplify_prog)
     \displayname "[:=][] assign"
 };

random_ass_box_left {
	\find (\modality{#box}#rdm\endmodality(post) ==>)  
	\replacewith(#randomass(\modality{#box}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
    \displayname "[:*] random"
};

random_ass_box_right {
	\find (==>\modality{#box}#rdm\endmodality(post))  
	\replacewith(==>#randomass(\modality{#box}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
    \displayname "[:*] random"
};

random_ass_boxtbox_left { 
	\find (\modality{#boxtbox}#rdm\endmodality(post)==>)
	\replacewith(post & (\modality{box}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
    \displayname "[:*][] random"
};

random_ass_boxtbox_right { 
	\find (==>\modality{#boxtbox}#rdm\endmodality(post))  
	\replacewith(==>post & (\modality{box}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
    \displayname "[:*][] random"
};

random_ass_dia_left { 
	\find (\modality{#dia}#rdm\endmodality(post)==>)  
	\replacewith(#randomass(\modality{#dia}#rdm\endmodality(post)) ==>) 
	\heuristics(simplify_prog)
    \displayname "<:*> random"
};

random_ass_dia_right { 
	\find (==>\modality{#dia}#rdm\endmodality(post))  
	\replacewith(==>#randomass(\modality{#dia}#rdm\endmodality(post))) 
	\heuristics(simplify_prog)
    \displayname "<:*> random"
};


////////////////////////////////////////
//
// Math Predicate Rules
//

   parity {\find (phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#parity(phi)) 
         \displayname "Parity decomposition"};
         
   to_less_equal_conjunct {\find (phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#toLessEqualConjunct(phi)) 
         \displayname "Convert to conjunction of <= atoms"
         \unicodename "<html><body>Convert to conjunction of &le; atoms</body></html>"};
         
   simplify_form {\find (phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#simplify(phi, true)) 
         \displayname "simplify arithmetic"};

   simplify_form_right {\find (==> phi) \varcond( \isFirstOrderFormula(phi))
      \replacewith (==> #simplify(phi, true)) 
		 \heuristics(mathematica_simplify) \noninteractive
         \displayname "simplify arithmetic"};

   simplify_form_left {\find (phi ==>) \varcond( \isFirstOrderFormula(phi))
      \replacewith (#simplify(phi, true) ==>) 
		 \heuristics(mathematica_simplify) \noninteractive
         \displayname "simplify arithmetic"};

   simplify_form_ass_right {
   \assumes( post ==>)
   \find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith ( ==> #simplify(phi, post)) 
         \displayname "simplify arithmetic assuming"};

   simplify_form_not_ass {
   \assumes( ==> post)
   \find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith ( ==> #simplify(phi, ! post)) 
         \displayname "simplify arithmetic assuming"};

   simplify_form_ass_left {
   \assumes( post ==> )
   \find ( phi ==>)   
   		\varcond( \isFirstOrderFormula(phi))
      \replacewith ( #simplify(phi, post) ==> ) 
         \displayname "simplify arithmetic assuming"};

   full_simplify_form {\find (phi)  
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith (#fullsimplify(phi)) 
         \displayname "simplify arithmetic (full)"};

   reduce_form {\find (phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith (#reduce(phi)) 
         \displayname "local QE arithmetic"};

   reduce_form_right {\find ( ==> phi)
   		\varcond( \isFirstOrderFormula(phi))
       \replacewith (==> #reduce(phi)) 
	  	\heuristics(mathematica_reduce) \noninteractive
         \displayname "local QE arithmetic"};

   reduce_form_left {\find (phi ==>)  
   	\varcond( \isFirstOrderFormula(phi))
       \replacewith (#reduce(phi) ==>) 
	  	\heuristics(mathematica_reduce) \noninteractive
         \displayname "local QE arithmetic"};
	
////////////////////////////////////////
//
// Rules for handling quantifiers
//
   
/*  allLeft { 
  	\find (\forall u; b ==>) 
  	\add ({\subst u; t}(b) ==>) 
  	\heuristics(gamma) 
	\oldname "all_left"
  };
  exRight { \find (==> \exists u; b) \add (==> {\subst u; t}(b)) 
            \heuristics(gamma) \oldname "ex_right" };
  allLeftHide { \find (\forall u; b ==>) \replacewith ({\subst u; t}(b) ==>)
		\addrules ( insert_hidden { \add (\forall u; b ==>) } )
                \heuristics(gamma_destructive) \oldname "all_left_hide" };
  exRightHide { \find (==> \exists u; b) \replacewith (==> {\subst u; t}(b))
		\addrules ( insert_hidden { \add (==> \exists u; b) } )
                \heuristics(gamma_destructive) \oldname "ex_right_hide" };
*/

  // Gamma rules
		//@todo \displayname "<html><body>&forall;l all left</body></html>"
  all_left { \find (\forall uC; b ==>) \replacewith ({\subst uC; qC}(b) ==>)
		    \addrules ( insert_hidden { \add (\forall uC; b ==>) } )
                    \heuristics(gamma_destructive)
                    \displayname "all left"
                    \unicodename "<html><body>&forall;l all left</body></html>"
                    };
  ex_right { \find (==> \exists uC; b) \replacewith (==> {\subst uC; qC}(b))
		    \addrules ( insert_hidden { \add (==> \exists uC; b) } )
                    \heuristics(gamma_destructive) 
                    \displayname "exists right"
                    \unicodename "<html><body>&exist;r exists right</body></html>"
                    };

  all_left_keep { 
  	\find (\forall uC; b ==>) 
  	\add ({\subst uC; qC}(b) ==>) 
  	\heuristics(gamma)
  	\displayname "all left (keep)"
    \unicodename "<html><body>&forall;l all left (keep)</body></html>"
  };

  ex_right_keep { \find (==> \exists uC; b)
             \add (==> {\subst uC; qC}(b))
  	     \heuristics(gamma)
         \unicodename "<html><body>&exist;r exists right (keep)</body></html>"
       	\displayname "exists right (keep)"
  	     };
   
  // delta rules
  all_right { \find (==> \forall uC; b) \varcond ( \new(skC, \dependingOn(b)) )
		\replacewith (==> {\subst uC; skC}b) \heuristics (delta)
		\displayname "all right"
        \unicodename "<html><body>&forall;r all right</body></html>"
		};
  ex_left { \find (\exists uC; b ==>) \varcond ( \new(skC, \dependingOn(b)) )
		\replacewith ({\subst uC; skC}b ==>) \heuristics (delta)
		\displayname "exists left"
        \unicodename "<html><body>&exist;l exists left</body></html>"
		};
 
  
 //pull out terms directly below query
 /*pullOut { \find ( tC ) \sameUpdateLevel \varcond ( \new(skC, \dependingOn(tC)) )
	       \replacewith (skC)
	       \add ( tC = skC ==>) 
	       \heuristics (query_normalize)
               \displayname "pull_out"
	  };

 //pull out terms somewhere below query
 pullOut2 { \find ( tC ) \sameUpdateLevel \varcond ( \new(skC, \dependingOn(tC)) )
	       \replacewith (skC)
	       \add ( tC = skC ==>) 
	       \displayname "pullOut"
	       \heuristics (query_normalize_high_costs)
               \displayname "pull_out"
	  };
*/

  // equality
  close_eq { \find (tC = tC) \replacewith (true) \heuristics (concrete) \displayname "close equality"};
  

  /* quantifier by substitution optimizations */

  all_singleton_left { \find(\forall u; ((u = q) -> phi))
    \varcond(\notFreeIn(u, q))
  	\replacewith ( {\subst u; q}phi)
	\displayname "all substitution"
	\unicodename "<html><body>&forall; all substitution</body></html>"
	\heuristics(concrete)
  };

  all_singleton_right { \find(\forall u; ((q = u) -> phi))
    \varcond(\notFreeIn(u, q))
  	\replacewith ( {\subst u; q}phi)
	\displayname "all substitution"
	\unicodename "<html><body>&forall; all substitution</body></html>"
	\heuristics(concrete)
  };

  ex_singleton_left { \find(\exists u; ((u = q) & phi))
    \varcond(\notFreeIn(u, q))
  	\replacewith ( {\subst u; q}phi)
	\displayname "exists substitution"
	\unicodename "<html><body>&exist; exists substitution</body></html>"
	\heuristics(concrete)
  };

  ex_singleton_right { \find(\exists u; ((q = u) & phi))
    \varcond(\notFreeIn(u, q))
  	\replacewith ( {\subst u; q}phi)
	\displayname "exists substitution"
	\unicodename "<html><body>&exist; exists substitution</body></html>"
	\heuristics(concrete)
  };

////////////////////////////////////////
//
// Propositional Rules
//

  // closing goals
  close_goal       { \assumes (b ==>) \find (==> b) \closegoal 
			    \heuristics(closure) \displayname "axiom_close"};
  close_goal_antec { \assumes (==> b) \find (b ==>) \closegoal \displayname "axiom_close"};
  close_by_false   { \find (false ==>) \closegoal \heuristics(closure) \displayname "axiom_close"};
  close_by_true    { \find (==> true) \closegoal \heuristics(closure) \displayname "axiom_close"};
  

  // simplify rules for "ReplaceKnownStrategy"
  replace_known_left  { \assumes ( b ==> ) \find ( b ) \sameUpdateLevel \replacewith ( true )
			   \heuristics(replace_known) \noninteractive };
  replace_known_right { \assumes ( ==> b ) \find ( b ) \sameUpdateLevel \replacewith ( false )
			   \heuristics(replace_known) \noninteractive };


  // junctor rules
  true_left    { \find (true ==>) \replacewith(==>) \heuristics(concrete) \displayname "true"};
  false_right  { \find (==> false) \replacewith(==>) \heuristics(concrete) \displayname "false"};

  not_left  { \find (! b ==>) \replacewith(==> b) \heuristics(alpha) \displayname "!l not left" \unicodename "<html><body>&not;l not left</body></html>"};
  not_right { \find (==> ! b) \replacewith(b ==>) \heuristics(alpha) \displayname "!r not right" \unicodename "<html><body>&not;r not right</body></html>" };

  imp_left  { \find (b -> c ==>) 
		\replacewith(==> b); 
                \replacewith(c ==>)
	      \heuristics(split,beta)
	      \displayname "->l imply left"
	      \unicodename "<html><body>&rarr;l imply left</body></html>"};
  imp_right { \find (==> b -> c) \replacewith(b ==> c) 
		\heuristics(alpha)
		\displayname "->r imply right"
		\unicodename "<html><body>&rarr;r imply right</body></html>"};

  and_left  { \find (b & c ==>) \replacewith(b, c ==>) \heuristics(alpha)
         \displayname "/\\l and left"
         \unicodename "<html><body>&and;l and left</body></html>" };
  and_right { \find (==> b & c) \replacewith(==> b); \replacewith(==> c) 
                    \heuristics(split,beta)
                    \displayname "/\\r and right"
                    \unicodename "<html><body>&and;r and right</body></html>" };
  or_left   { \find (b | c ==>) 
              "#b":\replacewith(b ==>); "#c":\replacewith(c ==>)
              \heuristics(split,beta)
              \displayname "\\/l or left"
              \unicodename "<html><body>&or;l or left</body></html>" };
  or_right  { \find (==> b | c) \replacewith(==> b, c) \heuristics(alpha)
              \displayname "\\/r or right"
              \unicodename "<html><body>&or;r or right</body></html>"};

//  equiv_left   { \find (b <-> c ==>) 
//		      \replacewith(b -> c, c -> b ==>)
//                    \heuristics(alpha_concrete) };

  equiv_left   { \find (b <-> c ==>) 
		      \replacewith(b, c ==>); 
                      \replacewith(==> b, c)
                    \heuristics(split,beta)
                    \displayname "<-> equivalence left"
                    \unicodename "<html><body>&harr;l equivalence left</body></html>"};
  
//  equiv_right  { \find (==> b <-> c) 
//		      \replacewith(==> b & c, !b & !c)
//                    \heuristics(alpha_concrete) };

  equiv_right  { \find (==> b <-> c) 
		    "Case ->": \replacewith(b ==> c);
                    "Case <-": \replacewith(c ==> b)
                    \heuristics(split,beta)
                    \displayname "<->r equivalence right"
                    \unicodename "<html><body>&harr;r equivalence right</body></html>" };

  /* These `recursive' rules are commented out, because this 
     keyword is not yet supported.
  imp_left_rec { \find (b -> c ==>)  \recursive 
		   \replacewith(==> b); 
                   \replacewith(c ==>) };
  and_right_rec { \find (==> b & c)  \recursive 
		    \replacewith(==> b); 
                    \replacewith(==> c) };
  or_left_rec { \find (b | c ==>)  \recursive
		  \replacewith(b ==>); 
                  \replacewith(c ==>) };
  */
  
  split_or_strong { \find (b | c ==>) 
		      \replacewith (b ==>); 
                      \replacewith(c ==> b) };

///////////////////////////////////////////////////////////////////////////////
// 8 beta rules that perform an implicit cut, i.e. that introduce lemmas.
// The treated cases occur frequently when splitting programs with if-branches.
// These rules are given slightly higher priority than the usual beta rules in
// strategy "Simple JavaCardLD"

  imp_left_lemma { \assumes (!b -> d ==>) \find (b -> c ==>)
                   \replacewith (==> b);
                   \replacewith (b, c ==>)
                   \heuristics(beta,beta_lemma) };

  imp_left_lemma_2 { \assumes (==> !b & d) \find (b -> c ==>)
                     \replacewith (==> b);
                     \replacewith (b, c ==>)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  imp_left_lemma_3 { \assumes (b -> d ==>) \find (!b -> c ==>)
                     \replacewith (b ==>);
                     \replacewith (c ==> b)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  imp_left_lemma_4 { \assumes (==> b & d) \find (!b -> c ==>)
                     \replacewith (b ==>);
                     \replacewith (c ==> b)
                     \heuristics(beta,beta_lemma)
                     \displayname "imp_left_lemma" };

  and_right_lemma { \assumes (!b -> d ==>) \find (==> b & c)
                    \replacewith (==> b);
                    \replacewith (b ==> c)
                    \heuristics(beta,beta_lemma) };

  and_right_lemma_2 { \assumes (==> !b & d) \find (==> b & c)
                      \replacewith (==> b);
                      \replacewith (b ==> c)
                      \heuristics(beta,beta_lemma)
                      \displayname "and_right_lemma" };

  and_right_lemma_3 { \assumes (b -> d ==>) \find (==> !b & c)
                    \replacewith (b ==>);
                    \replacewith (==> b, c)
                    \heuristics(beta,beta_lemma) };

  and_right_lemma_4 { \assumes (==> b & d) \find (==> !b & c)
                      \replacewith (b ==>);
                      \replacewith (==> b, c)
                      \heuristics(beta,beta_lemma)
                      \displayname "and_right_lemma" };

///////////////////////////////////////////////////////////////////////////////

  shift_paren_and { \find (b & (c & d)) \replacewith ((b & c) & d)
                        \heuristics(simplify) };
  shift_paren_or  { \find (b | (c | d)) \replacewith ((b | c) | d)
                        \heuristics(simplify) };
  commute_and { \find (b & c) \replacewith (c & b) };
  commute_or  { \find (b | c) \replacewith (c | b) };
  rotate_and { \find (b & (c & d)) \replacewith (c & (b & d)) };
  rotate_or  { \find (b | (c | d)) \replacewith (c | (b | d)) };
  
  // equivalence replacement
  insert_eqv_once_lr { \find (br <-> cr ==>) 
			\addrules( insert_eqv{ \find (br) \replacewith (cr)} )
		       \heuristics(simplify) \noninteractive };
  insert_eqv_once_rl { \find (br <-> cr ==>) 
			 \addrules( insert_eqv{ \find (cr) \replacewith (br)} )
                       \heuristics(simplify) \noninteractive };

  insert_eqv_lr { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (br) \replacewith (cr) 
					  \heuristics(simplify) } ) };
  insert_eqv_rl { \find (br <-> cr ==>)
		    \addrules( insert_eqv{ \find (cr) \replacewith (br) 
					  \heuristics(simplify) } ) };

  // simplification
  double_not { \find ( ! ( ! b)) \replacewith (b) \heuristics(concrete) \displayname "double negation" \unicodename "<html><body>&not;&not; double negation</body></html>"};

  concrete_not_1  { \find (! true) \replacewith (false) \heuristics(concrete) \displayname "simplify !true"};
  concrete_not_2  { \find (! false) \replacewith (true) \heuristics(concrete) \displayname "simplify !false"};

  concrete_impl_1 { \find (true -> b) \replacewith (b) \heuristics(concrete) \displayname "simplify true->"};
  concrete_impl_2 { \find (false -> b) \replacewith (true) \heuristics(concrete) \displayname "simplify false->"};
  concrete_impl_3 { \find (b -> false) \replacewith (! b) \heuristics(concrete) \displayname "simplify ->false"};
  concrete_impl_4 { \find (b -> true) \replacewith (true) \heuristics(concrete) \displayname "simplify ->true"};

  concrete_and_1  { \find (true & b) \replacewith (b) \heuristics(concrete) \displayname "simplify true&"};
  concrete_and_2  { \find (false & b) \replacewith (false) \heuristics(concrete) \displayname "simplify false&"};
  concrete_and_3  { \find (b & true) \replacewith (b) \heuristics(concrete) \displayname "simplify &true"};
  concrete_and_4  { \find (b & false) \replacewith (false) \heuristics(concrete) \displayname "simplify &false"};

  concrete_or_1   { \find (true | b) \replacewith (true) \heuristics(concrete) \displayname "simplify true|"};
  concrete_or_2   { \find (false | b) \replacewith (b) \heuristics(concrete) \displayname "simplify false|"};
  concrete_or_3   { \find (b | true) \replacewith (true) \heuristics(concrete) \displayname "simplify |true"};
  concrete_or_4   { \find (b | false) \replacewith (b) \heuristics(concrete) \displayname "simplify |false"};
  
  concrete_eq_1   { \find (true <-> b) \replacewith (b) \heuristics(concrete) \displayname "simplify true<->"};
  concrete_eq_2   { \find (false <-> b) \replacewith (! b) \heuristics(concrete) \displayname "simplify false<->"};
  concrete_eq_3   { \find (b <-> true) \replacewith (b) \heuristics(concrete) \displayname "simplify <->true"};
  concrete_eq_4   { \find (b <-> false) \replacewith (! b) \heuristics(concrete) \displayname "simplify <->false"};
  


  // other
  cut { "CUT: #b":\add (b ==>); "CUT: ! #b":\add (==> b) };

  cut_direct_r { \find (==> b) \replacewith (==> b); \add (b ==>) \noninteractive };
  cut_direct_l { \find (b ==>) \replacewith (b ==>); \add (==> b) \noninteractive };

  // proofobl not parsed yet.
  // rule_cut { \addrules (rule); \add (==> proofobl(rule)) };

  hide_left  { \find (b ==>) \replacewith (==>)
               \addrules( insert_hidden { \add (b ==>) } ) 
               //\heuristics(hiding)
			   \displayname "hide"
               };
  hide_right { \find (==> b) \replacewith (==>)
               \addrules( insert_hidden { \add (==> b) } ) 
               //\heuristics(hiding)
			   \displayname "hide"
               };

  case_distinction_r { \find (==> b)
		       \addrules( to_true  { \find (==> b) 
					      \replacewith(==>true)  
					    \heuristics(simplify)
					    \noninteractive } );
                       \addrules( to_false { \find (==> b) 
					      \replacewith(==>false) 
					    \heuristics(simplify) 
					    \noninteractive } )
                       \displayname "case_distinction"
			 \noninteractive
		     };

  case_distinction_l { \find (b ==>)
		       \addrules( to_true  { \find (b ==>) 
					      \replacewith(true ==>)  
					    \heuristics(simplify)
					    \noninteractive } );
                       \addrules( to_false { \find (b ==>) 
					     \replacewith(false ==>) 
					    \heuristics(simplify) 
					    \noninteractive } )
                       \displayname "case_distinction"
			 \noninteractive
		     };

////////////////////////////////////////
//
// special function rules
//
 

  absolute_value {
      \find(Abs(trm))
      \replacewith(\if(trm>=0) \then(trm) \else (-trm))
      // \heuristics(beta)  // @todo find the right heuristics rule
      \displayname "absolute value"
  };
  
  min_value {
      \find(Min(trm,trm2))
      \replacewith(\if(trm<=trm2) \then(trm) \else (trm2))
      // \heuristics(beta)  // @todo find the right heuristics rule
      \displayname "minimum value"
  };
  
  max_value {
      \find(Max(trm,trm2))
      \replacewith(\if(trm>=trm2) \then(trm) \else (trm2))
      // \heuristics(beta)  // @todo find the right heuristics rule
      \displayname "maximum value"
  };

}
