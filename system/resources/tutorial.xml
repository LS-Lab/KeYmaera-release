<?xml version="1.0" encoding="ISO-8859-1"?>
<description>
	<welcometext>
		Welcome to the KeYmaera tutorial overview...
	</welcometext>
	<tutorials>
		<tutorial name="Overview">
			<description>
				Overview over the KeYmaera input format
			</description>
			<exercise>
				<title>Input File Format</title>
				<description>
					<![CDATA[
					<h3 id="keymaerafile">Structure of KeYmaera Problem Specification File</h3>

					<p>
					A <kbd>.key</kbd> input file for KeYmaera specifies both the operational model of your hybrid system (using the notation of hybrid programs)
					and the correctness property that you want to verify.
					The verification problem is specified in a block called <kbd><span class="keyword">\problem</span> {...}</kbd> that contains the problem description as a <a href="#sec:dL">formula</a>.
					This block contains a single formula of <a href="../logic/dL.html" title="Differential Dynamic Logic for Hybrid Systems">differential dynamic logic&nbsp;(dL)</a>.
					For instance, this formula can characterize the initial state of the system using implications,
					the operational system specification using hybrid programs,
					and the safety/liveness/reactivity/controllability/... properties to show using modalities.
					</p>

					<p>
					The .key file format is quite flexible (there is a <a href="http://dx.doi.org/10.1007/978-3-540-69061-0_17">full description of KeY files</a> with all details except the <a href="#sec:dL">description of logical formulas in KeYmaera</a>).
					The canonical case has the following form
					</p>

					<pre>
	<span class="keyword">\sorts</span> {
	  /* declare two additional sorts C and D */
	  <span class="primitiveType">C</span>;
	  <span class="primitiveType">D</span>;
	}
	<span class="keyword">\functions</span> {
	  <span class="comment">/* symbolic parameter declarations */</span>
	  <span class="comment">/* they cannot change their values at runtime */</span>
	  <span class="primitiveType">R</span> para1;
	  <span class="primitiveType">R</span> para2;
	  /* declare a function as external, meaning it should be interpreted */
	  /* by the arithmetic backends */
	  \external R Sqrt(R);
	  /* declare a function that might be updated with 3 parameters */
	  \nonRigid[Location] C f(R,R,D);
	}

	<span class="keyword">\programVariables</span> {
		<span class="comment">/* state variable declarations */</span>
		<span class="primitiveType">R</span> x;
		<span class="primitiveType">R</span> y;
		<span class="primitiveType">R</span> z;
	}

	<span class="keyword">\problem</span> {
		<a href="#sec:dL">AFormula</a>
	}
					</pre>
					Here <a href="#sec:dL">AFormula</a> is a formula in differential dynamic logic (dL) following the <a href="#sec:dL">syntax of dL formulas</a>.
					This logical formula specifies the property that you are interested in.
					It will also include the system dynamics inside modalities following the <a href="#sec:HP">syntax of hybrid programs</a>.
					Often (but not always), the formula <a href="#sec:dL">AFormula</a> has the form
					<center>
					<kbd>&phi; -&gt; \[&alpha;\] &psi;</kbd>
					</center>
					of a safety property where <kbd>&phi;</kbd> is the formula specifying the precondition for the initial state and <kbd>&alpha;</kbd> is the hybrid program describing the system behavior and <kbd>&psi;</kbd> is the formula specifying the postcondition.
					This formula expresses that, when starting in a state satisfying <kbd>&phi;</kbd>, all behavior of <kbd>&alpha;</kbd> will lead to states satsifying formula <kbd>&psi;</kbd> (safety).
					Another common case for <a href="#sec:dL">AFormula</a> is
					<center>
					<kbd>&phi; -&gt; \&lt;&alpha;\&gt; &psi;</kbd>
					</center>
					This formula expresses that, when starting in a state satisfying <kbd>&phi;</kbd>, there is a behavior of system <kbd>&alpha;</kbd> that can lead to a state satsifying formula <kbd>&psi;</kbd>.
					Several other formulas including quantifiers and nested modalities can be used.
					See <a href="#sec:dL">syntax of formulas</a> for full details.
					]]>
				</description>
			</exercise>
			<exercise>
				<title>Hybrid Programs</title>
					<description>
						<![CDATA[
						<table class="syntax">
						  
						<tr>
						<td colspan="3" id="HP"><b>Hybrid programs</b>, with typical names <kbd>&alpha;</kbd> and <kbd>&beta;</kbd>, are defined by the following syntax:</td>
						</tr>
							
						<tr>
							<td></td><td><kbd>&alpha;; &beta;</kbd></td><td><em>Sequential composition</em> that runs <kbd>&alpha;</kbd> first and then <kbd>&beta;</kbd> after <kbd>&alpha;</kbd> stops (<kbd>&beta;</kbd> never starts if <kbd>&alpha;</kbd> never stops)</td>
						</tr> 
						<!--	<tr><td/><td><kbd>&#945;@invariant(&#966;)*</kbd> </td><td>Non-deterministic repetition with attached invariant constraint <kbd>&#966;</kbd></td></tr>  -->
							
						<tr>
						<td></td><td><kbd>x:=t</kbd> </td><td><em>Discrete assignment/jump</em> assigning the value of term <kbd>t</kbd> to <kbd>x</kbd></td>
						</tr>
							
						<tr>
						<td></td><td><kbd>x:=*</kbd> </td><td><em>Random assignment</em> assigns any real value to <kbd>x</kbd>, non-deterministically</td>
						</tr>
							
						<tr>
						<td></td><td nowrap="nowrap"><kbd><span class="keyword">if</span>(H)&nbsp;<span class="keyword">then</span>&nbsp;&alpha;&nbsp;<span class="keyword">fi</span></kbd> </td><td><em>If-then</em> statement, performs <kbd>&alpha;</kbd> if formula/condition <kbd>H</kbd> holds at current state and does nothing otherwise</td>
						</tr>
							
						<tr>
						<td></td><td nowrap="nowrap"><kbd><span class="keyword">if</span>(H)&nbsp;<span class="keyword">then</span>&nbsp;&alpha;&nbsp;<span class="keyword">else</span>&nbsp;&beta;&nbsp;<span class="keyword">fi</span></kbd></td><td><em>If-then-else</em> statement, performs <kbd>&alpha;</kbd> if <kbd>H</kbd> holds at current state and performs <kbd>&beta;</kbd> otherwise</td>
						</tr>
							
						<tr>
						<td></td><td><kbd>?H</kbd> </td><td><em>State assertion</em> testing whether formula <kbd>H</kbd> is true in current state (otherwise abort)</td>
						</tr>
							
						<tr>
						<td></td><td><kbd>&alpha; ++ &beta;</kbd></td><td><em>Non-deterministic choice</em> following either alternative   <kbd>&alpha;</kbd> or <kbd>&beta;</kbd></td>
						</tr>
							
						<tr>
						<td></td><td><kbd><span class="keyword">while</span>(H)&nbsp;&alpha;&nbsp;<span class="keyword">end</span></kbd></td><td><em>While loop</em>, repeats <kbd>&alpha;</kbd> as long as <kbd>H</kbd> holds, stops before doing <kbd>&alpha;</kbd> only if <kbd>H</kbd> is false
							 (<kbd>&alpha;</kbd> will not be stopped in the middle just because <kbd>H</kbd> becomes false at some intermediate state during <kbd>&alpha;</kbd>).</td>
						</tr>
							
						<tr>
						<td></td><td><kbd>&alpha;<sup>*</sup></kbd> </td><td><em>Non-deterministic repetition</em>, repeating <kbd>&alpha;</kbd> arbitrarily often including 0 times</td>
						</tr>
							
						<tr>
						<td></td><td nowrap="nowrap"><kbd>{x'=t,y'=s,&nbsp;H}</kbd> </td><td><em>Continuous evolution</em> along <em>differential equation system</em> with terms <kbd>t,s</kbd>, optionally with <em>evolution domain constraint</em> <kbd>H</kbd>.
							This domain constraint <kbd>H</kbd> needs to be true <em>at every time</em> during the evolution, otherwise the system needs to stop following this continuous mode and move on.
							You can use systems of differential equations, differential-algebraic equations, differential inequalities, and differential equations with disturbances.</td>
						</tr>
							
						<tr>
						<td></td><td><kbd>{x'=t,y'&lt;=s,y'&gt;=r,&nbsp;H}</kbd> </td><td><em>Continuous evolution</em> along <em>system of differential equations and differential inequalities</em> with terms <kbd>t,s,r</kbd>, optionally with evolution domain <kbd>H</kbd>. The time-derivative of <kbd>y</kbd> needs to stay within <kbd>r</kbd> and <kbd>s</kbd> all the time.</td>
						</tr>
							
						<tr>
						<td></td><td><kbd>{<span class="keyword">\exists</span>&nbsp;R&nbsp;u;&nbsp;(x'=t &amp; y'=s&nbsp;&amp;&nbsp;H)}</kbd> </td><td><em>Continuous evolution</em> along <em>system of differential-algebraic equations</em> with disturbance <kbd>u</kbd> (which may occur in the terms <kbd>t,s</kbd> and formula <kbd>H</kbd>), optionally with evolution domain <kbd>H</kbd>.</td>
						</tr>
							
						<tr>
						<td></td><td id="vardecl"><kbd><span class="X:primitiveType">R</span> x</kbd> </td><td><em>Variable declaration</em>, declaring <kbd>x</kbd> as a real variable (either a state variable or auxiliary variable).
							<!-- We recommend that variable names start with lowercase letters. --></td>
						</tr>
							
						<tr>
						<td></td><td><kbd><span class="X:primitiveType">R</span> x, y, z</kbd> </td><td><em>Variable declaration</em>, declaring <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> as real variables</td>
						</tr>
							
						<tr>
						<td colspan="3">where <kbd>H</kbd> is a formula of (possibly non-linear) real arithmetic (possibly including quantifiers, but no modalities).</td>
						</tr>

						</table>

						Enriching this syntax for QdL:

						You can add a single quantifier in front of assignments, random assignments, and differential equation systems. Instead of variables you may use non-rigid function symbols with parameters.
						]]>
					</description>
			</exercise>
			<exercise>
				<title>Formulas</title>
				<description>
					<![CDATA[
					<table class="syntax">
					  
					<tr>
					<td colspan="3" id="syntax"><b>Formulas of <a href="../logic/dL.html" title="Differential Dynamic Logic for Hybrid Systems">dL</a></b>, with typical names <kbd>&phi;</kbd> and <kbd>&psi;</kbd>, are defined by the following syntax</td>
					</tr>
					  
					<tr>
					<td></td> 
						<td nowrap="nowrap">
						<kbd><span class="keyword">\forall</span>&nbsp;R&nbsp;x;&nbsp;&phi;</kbd>
						</td>
						<td><em>Universal quantifier</em>: for all real values for variable <kbd>x</kbd>, formula <kbd>&phi;</kbd> holds</td>
						
					</tr>
						
					<tr>
						
					<td></td>
						<td nowrap="nowrap"><kbd><span class="keyword">\exists</span>&nbsp;R&nbsp;x;&nbsp;&phi;</kbd></td>
						<td><em>Existential quantifier</em>: for some real value for variable <kbd>x</kbd>, formula <kbd>&phi;</kbd> holds</td>
						
					</tr>
						
					<tr>
					<td></td><td><kbd>!&phi;</kbd></td><td><em>Negation</em> (not)</td>
					</tr> 
						
					<tr>
					<td></td><td><kbd>&phi; &amp; &psi;</kbd></td><td><em>Conjunction</em> (and)</td>
					</tr> 
						
					<tr>
					<td></td><td><kbd>&phi; | &psi;</kbd></td><td><em>Disjunction</em> (or)</td>
					</tr>
						
					<tr>
					<td></td><td><kbd>&phi;&nbsp;-&gt;&nbsp;&psi;</kbd></td><td><em>Implication</em> (implication)</td>
					</tr>
						
					<tr>
					<td></td><td><kbd>&phi;&nbsp;&lt;-&gt;&nbsp;&psi;</kbd></td><td><em>Biimplication</em> (equivalence)</td>
					</tr>
						
					<tr>
					<td></td><td><kbd>\[<a href="#HP">&alpha;</a>\] &phi;</kbd></td><td><em>Box-modality</em>: After all runs of <a href="#HP">hybrid program</a> <kbd>&alpha;</kbd>, formula <kbd>&phi;</kbd> holds (safety)</td>
					</tr>
						
					<tr>
					<td></td><td><kbd>\&lt;<a href="#HP">&alpha;</a>\&gt; &phi;</kbd></td><td><em>Diamond-modality</em>: There is at least one run of <a href="#HP">hybrid program</a> <kbd>&alpha;</kbd>, after which formula <kbd>&phi;</kbd> holds (liveness)</td>
					</tr>
						
					<tr>
					<td></td><td><kbd>\[[<a href="#HP">&alpha;</a>\]] &phi;</kbd></td><td><em>Temporal-box-modality</em>: During all runs of <a href="#HP">hybrid program</a> <kbd>&alpha;</kbd>, formula <kbd>&phi;</kbd> holds (safety throughout)</td>
					</tr>
						
					<tr>
					<td></td><td><a href="#predicate">pred</a></td> <td><a href="#predicate">Real arithmetic predicate expression</a></td>
					</tr>
				</table>

					<ul>
						<li>Enriching this syntax for QdL: You may use different sorts instead of R that have been defined in the input file. </li>
						<li>Enriching this syntax for dDGL: You have another modality \( \), the game modality. Inside this modality you may write other modalities, sequences of modalities, choices between modalities (++) or (+-+), and repetions (^[*]) and (^&lt;*&gt;).</li>
					</ul>
						]]>
					</description>
			</exercise>
			<exercise>
				<title>Terms</title>
				<description>
					<![CDATA[
					<table class="syntax">
					<tr>
					<td id="term" colspan="3"><b>Real arithmetic terms</b>, with typical names <kbd>s</kbd> and <kbd>t</kbd>, are defined by the following syntax</td>
					</tr>
						
					<tr>
					<td></td><td><kbd>t + s</kbd></td><td>Addition</td>
					</tr>
						
					<tr>
					<td></td><td><kbd>t - s</kbd></td><td>Subtraction</td>
					</tr> 
						
					<tr>
					<td></td><td><kbd>t * s</kbd></td><td>Multiplication</td>
					</tr> 
						
					<tr>
					<td></td><td><kbd>t / s</kbd></td><td>Division</td>
					</tr> 
						
					<tr>
					<td></td><td><kbd>t^n</kbd></td><td>Power with integer <kbd>n</kbd></td>
					</tr> 
						
					<tr>
					<td></td><td><kbd>- s</kbd></td><td>Minus</td>
					</tr> 
						
					<tr>
					<td></td><td><kbd>f(t1,...,tn)</kbd></td><td>Function application</td>
					</tr> 
						
					<tr>
					<td></td><td>VARIABLE</td><td>An arbitrary variable identifier (that <a href="#vardecl">has been declared</a>)</td>
					</tr> 
						
					<tr>
					<td></td><td>NUMBER</td><td>An arbitrary decimal number</td>
					</tr>

					</table>
					]]>
				</description>
			</exercise>
		</tutorial>
		<tutorial name="Verified Software Summer School 2012">
			<description>
				This tutorial contains the exercises used at the Verified Software Summer School 2012.
			</description>
			<exercise>
				<title>Ex. 1 Pen&amp;Paper Modelling</title>
				<description>Use Pen&amp;Paper to model a car.</description>
			</exercise>
			<exercise>
				<title>Ex. 2 Continuous dynamics</title>
				<description>
				<![CDATA[
					<h3>Modeling a safety property of a continuous system</h3>
					<p>
					This is a simple system in which a car starts at some velocity v and accelerates at constant rate A along a straight lane.
					The requirement we want to prove is that the car may never travel backward, i.e. the velocity v is always greater than or equal to zero.
					</p>
					<b>Exercise:</b> 
					Load the exercise and press play. The automatic strategy is able to prove this example. Look at the proof and try to understand its structure.
				]]>
				</description>
				<path>/examples/hybrid/tutorial/lics1-continuous-forward.key</path>
			</exercise>
			<exercise>
				<title>Ex. 3 Safety of simple car control</title>
				<description>
				<![CDATA[
					<h3>Modeling a safety property of a hybrid system</h3>
					<p>
					In this example, we introduce a discrete controller into the
					model of the continuous car system in Example 2. The controller has
					only two options: it may either cause the car to accelerate with rate
					A&gt;0 or to brake with rate -b&lt;0.
					</p>
					<b>Exercise:</b>
					<ul>
						<li>Load the exercise and press play. The automatic strategy is able to prove this example.</li>
						<li>Investigate the resulting proof. Which loop invariant did the strategy use? Why?</li>
					</ul>
				]]>
				</description>
				<resources>
					<img>/examples/hybrid/tutorial/fig-car-stuck-accel-accel.png</img>
					<img>/examples/hybrid/tutorial/fig-car-stuck-accel-vel.png</img>
					<img>/examples/hybrid/tutorial/fig-car-stuck-accel-pos.png</img>
				</resources>
				<path>/examples/hybrid/tutorial/lics2-hybrid-forward.key</path>
			</exercise>
			<exercise>
				<title>Ex. 4 Event-triggered car</title>
				<description>
				<![CDATA[
					<p>
					While the car is driving down the lane, the controller must
					choose when to begin decelerating so that it always stops
					before the stop sign m.  In order to make sure that the car
					controller does not miss the event when it is time to start
					braking, we add an additional constraint to the
					evolution domain of the differential equation. This models an event triggered system.  In
					this case, the event-trigger is when the distance between
					the car and the stop sign equals the stopping distance of
					the car. This example shows that the system still can never
					travel backwards.
					</p>
					<b>Exercise:</b>
					<ul>
						<li>Load the exercise in KeYmaera.</li>
						<li>Go to your <tt>Hybrid Strategy</tt> tab and make sure that <tt>Differential Saturation</tt> is turned <b>off</b> (this disables some of KeYmaera's automation).</li> 
						<li>Use KeYmaera to prove that the car is safe.</li>
					</ul>
				]]>
				</description>
                <hints>
                	<hint id="4.1">
                		You need to provide a loop invariant interactively, because KeYmaera's <tt>Differential Saturation</tt> is turned off.
                	</hint>
                	<hint id="4.2">
                		Apply the <tt>ind loop invariant</tt> rule and type your invariant into the field for <tt>inv</tt>.
                	</hint>
                	<hint id="4.3">
                		In order to find a good invariant, think about what you want to prove and what will always remain true about the car.
                	</hint>
                	<hint id="4.4">
                		<![CDATA[
                		The invariant is v &ge; 0
                		]]>
                	</hint>
                </hints>
				<resources>
					<img>/examples/hybrid/tutorial/fig-car-accel-brake-accel.png</img>
					<img>/examples/hybrid/tutorial/fig-car-accel-brake-vel.png</img>
					<img>/examples/hybrid/tutorial/fig-car-accel-brake-pos.png</img>
				</resources>
				<path>/examples/hybrid/verifiedsoft/event-triggered-car.key</path>
			</exercise>
			<exercise>
				<title>Ex. 5 Time-triggered car</title>
				<description>
				<![CDATA[
					<h3>Time-triggered safe if braking safe</h3>
					<p>
					In a realistic system, the sensors on the car would take periodic measurements
					of position x and velocity v and the controller would only execute each time those
					sensor updates are taken. We continue with the single car travelling toward a
					stop sign. This time we change the model so that it only receives periodic updates about its position and velocity.  The
					time t between sensor updates is bounded by ep. Prove that the car controller
					will always make the car stay before the traffic light if braking would.
					</p>
					<p>
					Variable Definitions:
					<ul>
					  <li> <b>x</b> position of car</li>
					  <li> <b>v</b> velocity of car
					  <li> <b>a</b> acceleration of car</li>
					  <li> <b>A</b> max acceleration</li>
					  <li> <b>b</b> max braking</li>
					  <li> <b>m</b> position of Stop Sign</li>
					</ul>
					</p>
					<p>
					Hint: To prove quickly, instantiate the time quantifier in the antecedent by the time
					variable of the succedent (e.g. t5_0).
					</p>
					<b>Exercise:</b>
					<ul>
						<li>Load the exercise.</li>
						<li>Go to your <tt>Hybrid Strategy</tt> tab and make sure that <tt>Differential Saturation</tt> is turned <b>off</b> (this disables some of KeYmaera's automation).</li> 
						<li>Use KeYmaera to prove that the car is safe.</li>
					</ul>
				]]>
				</description>
				<hints>
					<hint id="5.1">
						The invariant necessary in this example characterizes the region where the car is still controllable.
					</hint>
					<hint id="5.2">
						The invariant relates v, b, m, and x.
					</hint>
					<hint id="5.3">
						<![CDATA[
						The invariant is v<sup>2</sup> &lt;= 2*b*(m-z)
						]]>
					</hint>
				</hints>
				<resources>
					<img>/examples/hybrid/tutorial/fig-car-too-fast-accel.png</img>
					<img>/examples/hybrid/tutorial/fig-car-too-fast-vel.png</img>
					<img>/examples/hybrid/tutorial/fig-car-too-fast-pos.png</img>
				</resources>
				<path>/examples/hybrid/verifiedsoft/time-safe-relative.key</path>
			</exercise>
			<exercise>
				<title>Ex. 6 Water Tank</title>
				<description>
				<![CDATA[
					<p>
					This example models a water tank. The water level (named y) is supposed to be between 1 and 12. Another variable x is used as a clock to model delays while switching modes, because it takes time until the pump activates.
					</p>

					<p>
					The system has two main modes:
					<ul>
					<li> st = 0: is the mode where water is flowing into the tank with a constant rate of 1.</li>
					<li> st = 2: is the mode where water is draining from the tank with a constant rate of -2.</li>
					</ul>
					</p>
					<p>
					The modes st = 1 and st = 3 model the delays while switching between modes 0 and 2.
					<ul>
					<li> st = 1: is the mode where water is still flowing into the tank with a constant rate of 1 for another <b>2 time units</b> before switching to mode st = 2.</li>
					<li> st = 3: is the mode where water is still draining from the tank with a constant rate of -2 for another <b>2 time units</b> beofre switching to mode st = 0</li>
					</ul>
					</p>
					<p>
						<b>Exercise:</b>
						<ul>
							<li>Load the example.</li>
    						<li>Go to your <tt>Hybrid Strategy</tt> tab and make sure that <tt>Differential Saturation</tt> is turned <b>off</b> (this disables some of KeYmaera's automation).</li> 
							<li>Press play. The automatic strategy is able to prove this example using the annotated loop @invariant(...) in the input file. Inspect the proof structure.</li>
					</p>
				
				]]>
					
				</description>
				<resources>
					<img>/examples/hybrid/water_tank/fig-water-tank.png</img>
				</resources>
			    <path>/examples/hybrid/publish/water_tank.key</path>
			</exercise>
			<exercise>
				<title>Ex. 7 Parametric Water Tank</title>
				<description>
					<![CDATA[
					<p>
					This example models a parametric version of the water tank. Now, the water level (named y) is supposed to be between min_fill and max_fill. Another variable x is used as a clock to model delays while switching modes. The delay is bounded by a constant max_com.
					The water level is now increased with constant rate <b>f</b>&gt;0 instead of 1 and decreased with constant rate <b>-d</b>&lt;<0 instead of -2.
					</p>

					<p>
						The system has two main modes (for f > 0 & d > 0):
					<ul>
						<li> st = 0: is the mode where water is flowing into the tank with a constant rate of <b>f</b>.</li>
						<li> st = 2: is the mode where water is draining from the tank with a constant rate of <b>-d</b>.</li>
					</ul>
					</p>
					<p>
					The modes st = 1 and st = 3 model the delays while switching between modes 0 and 2.
					<ul>
					<li> st = 1: is the mode where water is still flowing into the tank with a constant rate of f for <i>at most</i> <b>max_com time units</b> before switching to mode st = 2.</li>
					<li> st = 3: is the mode where water is still draining from the tank with a constant rate of -d for <i>at most</i> <b>max_com time units</b> beofre switching to mode st = 0</li>
					</ul>
					</p>
					<p>
						<b>Exercise:</b> Load the example and prove that the input is a tautology. Note that in contrast to the previous exercise the loop invariant is not given.
					</p>
				]]>
				</description>
				<hints>
					<hint id="7.1">
						The invariant you need to provide is similar to the non-parametric invariant.
					</hint>
					<hint id="7.2">
						The invariant needs to talk about what holds in each mode.
					</hint>
					<hint id="7.3">
						Check the initial region for helpful constraints that could be part of the invariant.
					</hint>
					<hint id="7.4">
					<![CDATA[
						The invariant is:<br/>
						(st = 0 | st = 1 | st = 2 | st =3)<br/>
						&amp;<br/>
						x &gt;= 0 &amp; x &lt;= max_com<br/>
						&amp;<br/>
						(st =0 -&gt; (y &gt;= min_fill &amp; y &lt;= max_fill - f*max_com))<br/>
						&amp;<br/>
						(st = 1 -&gt; (y &gt;= min_fill+d*max_com &amp; y &lt;= max_fill - f*(max_com - x)))<br/>
						&amp;<br/>
						(st =2 -&gt; (y &gt;= min_fill+d*max_com &amp; y &lt;= max_fill))<br/>
						&amp;<br/>
						(st = 3 -&gt; (y &gt;= min_fill + d*(max_com-x) &amp; y &lt;= max_fill - f*max_com)))
					]]>
					</hint>
				</hints>
				<resources>
					<img>/examples/hybrid/water_tank/fig-water-tank.png</img>
				</resources>
				 <path>/examples/hybrid/verifiedsoft/general_water_tank.key</path>
			</exercise>
			<exercise>
				<title>Ex. 8 Cooling down</title>
				<description>
					<![CDATA[
					<p>
						A room with a temperature <b>x</b> of more than 10 degrees within an enviornment with constant temperature of 10 degrees is bound to cool down. 
						We model this system by the differential equation <b>x' = 10 - x</b>. 
					</p>
					
					<p>
						<b>Exercise:</b> Prove that if this system is started with an inital value greater than 10 it always stays greater than 10.
					</p>
					]]>
				</description>
				<hints>
					<hint id="8.1">
					<![CDATA[
						Proving this is similar to proving that<br> x &lt; 0 -&gt; \[x'=-x\] x &lt; 0
					]]>
					</hint>
					<hint id="8.2">
					<![CDATA[
						Proofs of x &lt; 0 -&gt; \[x'=-x\] x &lt; 0 need a DA differential auxiliary.
					]]>
					</hint>
					<hint id="8.3">
					<![CDATA[
						Adding squares sometimes has more information than ground terms.
					]]>
					</hint>
					<hint id="8.4">
					<![CDATA[
					Proofs of x &lt; 0 -&gt; \[x'=-x\] x &lt; 0 need the DA differential auxiliary y'=y/2 with x*y^2=1. 
					]]>
					</hint>
					<hint id="8.5">
					<![CDATA[
						Consider (x-10) in place of x in the previous hints.
					]]>
					</hint>
				</hints>
				<resources>
					<img>/examples/hybrid/heater/diffcut.png</img>
				</resources>
				<path>/examples/hybrid/heater/diffcut.key</path>
			</exercise>
			<exercise>
				<title>Ex. 9 Heating up</title>
				<description>
					<![CDATA[
					<p>
					Now we put a heater into the room from the previous exercise.
					The heater constantly increases the temperature in the room.
					Further, we add some isolation to the room to slow down
					temperature exchange. This is modelled by the
					differential equation<br>
					<b>x' = 15 + 1/2*(10-x)</b>.
					</p>
					<p>
						<b>Exercise:</b> Prove that if this system is started with an inital temperatur less than 40, then it always stays less than 40.
					</p>
					]]>
				</description>
				<hints>
					<hint id="9.1">
						Try to find a formula for DA differential auxiliaries that is similar to the DA formula used in the cooling example.
					</hint>
					<hint id="9.2">
					<![CDATA[
						What is equivalent to x &lt; 40 and contains y^2?
					]]>
					</hint>
					<hint id="9.3">
					<![CDATA[
						Try using x*y^2=-1.
					]]>
					</hint>
				</hints>
				<resources>
					<img>/examples/hybrid/heater/diffcut2.png</img>
				</resources>
				<path>/examples/hybrid/heater/diffcut2.key</path>
			</exercise>
			<exercise>
				<title>Ex. 10 Not too cold</title>
				<description>
					<![CDATA[
					<p>
					In the previous exercise we have shown that there is an
					upper bound for the temperature when heating. Now we want to show that
					of course there is a lower bound as well.
					</p>
					Reminder: The system is still modelled by the differential equation <b>x' = 15 + 1/2*(10-x)</b>.
					</p>
					<p>
						<b>Exercise:</b> Prove that if this system is started with an inital temperature between 20 and 30, then it always stays above 15.
					</p>
					]]>
				</description>
				<resources>
					<img>/examples/hybrid/heater/diffcut2.png</img>
				</resources>
				<path>/examples/hybrid/heater/diffcut3.key</path>
			</exercise>
			<exercise>
				<title>Ex. 11 Temperature in hot cases</title>
				<description>
					<![CDATA[
					<p>
					So we know that there is an upper bound for certain cases
					and a lower bound for certain cases. What happens if we
					start with an arbitrary value above 15 degrees?
					</p>
					Reminder: The system is still modelled by the differential equation <b>x' = 15 + 1/2*(10-x)</b>.
					</p>
					<p>
						<b>Exercise:</b> Prove that if this system is started with an inital temperature greater than 15 it always stays above 15.
					</p>
					]]>
				</description>
				<resources>
					<img>/examples/hybrid/heater/diffcut2.png</img>
					<img>/examples/hybrid/heater/diffcut3.png</img>
					<img>/examples/hybrid/heater/diffcut4.png</img>
				</resources>
				<path>/examples/hybrid/heater/diffcut4.key</path>
			</exercise>
			<exercise>
				<title>Ex. 12 Heater (extract)</title>
				<description>
					<![CDATA[
					<p>
					The differential equations considered in the previous execises are the modes of a heater system. The outside temperature is assumed to be 10 degrees.
					The goal of the heating system is to guarantee an inside temperature of <b>at least 15 degrees</b>. The control strategy for the heater is underspecified. 
					However, it might only be turned off when the current temperature is <b>at least 20 degrees</b>. Due to mechanical restrictions can stay turned off for at most <b>1/2 time units</b>.
					</p>
					<p>
						<b>Exercise:</b> Prove that if the current temperature is above 20 degrees, the temperature does not fall below 15 degrees within the next 1/2 time units when the heater is switched off.</b> 
					</p>
					]]>
				</description>
				<hints>
					<hint id="12.0">Try using differential induction</hint>
					<hint id="12.1">The input file defines a function R Log(R) as \external</hint>
				</hints>
				<resources>
					<img>/examples/hybrid/verifiedsoft/cooling.png</img>
					<img>/examples/hybrid/verifiedsoft/cooling2.png</img>
				</resources>
				<path>/examples/hybrid/verifiedsoft/heater-switchdelay-extract.key</path>
			</exercise>
			<exercise>
				<title>Ex. 13 Heater (extract 2)</title>
				<description>
					<![CDATA[
					<p>
					The differential equations considered in the previous execises are the modes of a heater system. The outside temperature is assumed to be 10 degrees.
					The goal of the heating system is to guarantee an inside temperature of <b>at least 15 degrees</b>. The control strategy for the heater is underspecified. 
					However, it might only be turned off when the current temperature is <b>at least 20 degrees</b>. Due to mechanical restrictions can stay turned off for at most <b>1/2 time units</b>.
					</p>
					<p>
						<b>Exercise:</b> Prove that if the current temperature is above 15 degrees, the temperature rises above 20 degrees within 1/2 time units while heating.</b> 
					</p>
					]]>
				</description>
				<resources>
					<img>/examples/hybrid/verifiedsoft/heating.png</img>
					<img>/examples/hybrid/heater/diffcut4.png</img>
				</resources>
				<path>/examples/hybrid/verifiedsoft/heater-switchdelay-extract2.key</path>
			</exercise>
			<exercise>
				<title>Ex. 14 Distributed cars</title>
				<description>
					<![CDATA[
					<p>
					Consider the following example of two cars. It is modelled in QdL.
					</p>
					<p>
						<b>Exercise:</b> Prove that the two cars do not collide
					</p>
					]]>
				</description>
				<resources>
					<img>/examples/hybrid/qdl/fig-distributed-car-control.png</img>
				</resources>
				<path>/examples/hybrid/qdl/llcsimpler.key</path>
			</exercise>
			<exercise>
				<title>Challenges</title>
				<description>
					<![CDATA[
					<ul>
						<li>Model an instance of the heater example with 4 rooms, 2 heaters, and a strategy for moving the heaters from room to room. Prove that your model satisfies an interesting safety property about the temperature in each room.</li>
						<li>Prove a diamond property for the heater example.</li>
						<li>Make the heater example with two rooms parametric w.r.t. to outside temperature, isolation, temperature exchange ratio, etc. and find suitable constraints such that it remains safe.</li>
						<li>Model the heater example with QdL and prove that it is safe for arbitrarily many rooms and arbitrarily many heaters (less than rooms).</li>
					</ul>
					]]>
				</description>
			</exercise>

		</tutorial>
	</tutorials>
</description>
