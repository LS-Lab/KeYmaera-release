diff --git a/examples/_testcase/testgen/BranchingLoop.java b/examples/_testcase/testgen/BranchingLoop.java
new file mode 100644
index 0000000..a7bfa22
--- /dev/null
+++ b/examples/_testcase/testgen/BranchingLoop.java
@@ -0,0 +1,23 @@
+public class BranchingLoop {
+
+	/*@ public normal_behavior
+	  @ ensures true;
+	  @ diverges true;
+	  @ */
+	public void doIt(int n){
+		int i=0;
+		int oldN = n;
+		//@ loop_invariant (i+4) / (1+n-oldN) ==  4; modifies i,n;
+		while(i < n*2){
+			n+=2;
+			if(i >= 64){
+				foo(n); //NOP
+			}
+			i+=8;
+		}
+	}
+	
+	public void foo(int n){
+		//dummy
+	}
+}
diff --git a/examples/_testcase/testgen/absMin.key b/examples/_testcase/testgen/absMin.key
new file mode 100644
index 0000000..f77aacc
--- /dev/null
+++ b/examples/_testcase/testgen/absMin.key
@@ -0,0 +1,83 @@
+\settings {
+"#Proof-Settings-Config-File
+#Fri Jun 26 11:44:18 CEST 2009
+[General]SoundNotification=false
+[View]FontIndex=2
+[StrategyProperty]GOALCHOOSER_OPTIONS_KEY=GOALCHOOSER_DEFAULT
+[General]UseOCL=false
+[StrategyProperty]METHOD_OPTIONS_KEY=METHOD_EXPAND
+[StrategyProperty]USER_TACLETS_OPTIONS_KEY3=USER_TACLETS_OFF
+[StrategyProperty]LOOP_OPTIONS_KEY=LOOP_INVARIANT
+[StrategyProperty]USER_TACLETS_OPTIONS_KEY2=USER_TACLETS_OFF
+[StrategyProperty]USER_TACLETS_OPTIONS_KEY1=USER_TACLETS_OFF
+[SimultaneousUpdateSimplifier]DeleteEffectLessLocations=false
+[StrategyProperty]QUANTIFIERS_OPTIONS_KEY=QUANTIFIERS_NON_SPLITTING_WITH_PROGS
+[StrategyProperty]NON_LIN_ARITH_OPTIONS_KEY=NON_LIN_ARITH_NONE
+[DecisionProcedure]Timeout=60
+[View]ShowWholeTaclet=false
+[General]ProofAssistant=false
+[View]MaxTooltipLines=40
+[General]DnDDirectionSensitive=true
+[SimultaneousUpdateSimplifier]EagerSimplification=true
+[General]StupidMode=true
+[Strategy]Timeout=-1
+[Strategy]MaximumNumberOfAutomaticApplications=1000
+[Libraries]Default=acc.key-false, stringRules.key-false, /home/mbender/.key/libraries/stringRules.key-false, /home/mbender/.key/libraries/deprecatedRules.key-false, deprecatedRules.key-false, /home/mbender/.key/libraries/acc.key-false
+[StrategyProperty]QUERY_OPTIONS_KEY=QUERY_NONE
+[Choice]DefaultChoices=transactions-transactions\:transactionsOn , throughout-throughout\:toutOn , assertions-assertions\:on , programRules-programRules\:Java , intRules-intRules\:arithmeticSemanticsIgnoringOF , initialisation-initialisation\:disableStaticInitialisation , transactionAbort-transactionAbort\:abortOn , nullPointerPolicy-nullPointerPolicy\:nullCheck , testGeneration-testGeneration\:testOn , javacard-javacard\:jcOff
+[StrategyProperty]STOPMODE_OPTIONS_KEY=STOPMODE_DEFAULT
+[DecisionProcedure]ActiveRule=_noname_
+[General]UseJML=true
+[View]HideClosedSubtrees=false
+[Choice]Choices=throughout-throughout\:toutOn-throughout\:toutOff , transactions-transactions\:transactionsOn-transactions\:transactionsOff , assertions-assertions\:on-assertions\:off-assertions\:safe , intRules-intRules\:javaSemantics-intRules\:arithmeticSemanticsIgnoringOF-intRules\:arithmeticSemanticsCheckingOF , programRules-programRules\:Java-programRules\:ODL , initialisation-initialisation\:enableStaticInitialisation-initialisation\:disableStaticInitialisation , transactionAbort-transactionAbort\:abortOn-transactionAbort\:abortOff , nullPointerPolicy-nullPointerPolicy\:noNullCheck-nullPointerPolicy\:nullCheck , javacard-javacard\:jcOff-javacard\:jcOn
+[View]HideIntermediateProofsteps=false
+[Strategy]ActiveStrategy=VBTStrategy
+[StrategyProperty]SPLITTING_OPTIONS_KEY=SPLITTING_DELAYED
+"
+}
+
+\javaSource "/home/mbender/key/examples/testGen/absMin";
+
+
+
+\programVariables {
+java.lang.Throwable exc;
+int _a;
+int _b;
+int a;
+int b;
+int result;
+}
+
+\functions {
+}
+
+\predicates {
+}
+
+\problem {
+   inReachableState & (inInt(a) & inInt(b))
+-> {_a:=a ||
+     _b:=b}
+     \<{
+         exc=null;try {
+           result=AbsMin.absMin(_a,_b)@AbsMin;
+         }  catch (java.lang.Throwable e) {
+           exc=e;
+         }
+       }\> (    result
+              = (jint)(\if (   (jint)(\if (a <  b)
+                                          \then (a)
+                                          \else (b))
+                            <  (jint)(0))
+                           \then ((jint)-((jint)(\if (   a
+                                                      <  b)
+                                                     \then (a)
+                                                     \else (b))))
+                           \else ((jint)(\if (a <  b)
+                                             \then (a)
+                                             \else (b))))
+            & exc = null)
+
+}
+
diff --git a/examples/_testcase/testgen/branchingLoop.proof b/examples/_testcase/testgen/branchingLoop.proof
new file mode 100644
index 0000000..328b13e
--- /dev/null
+++ b/examples/_testcase/testgen/branchingLoop.proof
@@ -0,0 +1,541 @@
+\settings {
+"#Proof-Settings-Config-File
+#Fri Jul 10 16:17:30 CEST 2009
+[General]SoundNotification=false
+[View]FontIndex=2
+[StrategyProperty]GOALCHOOSER_OPTIONS_KEY=GOALCHOOSER_DEFAULT
+[General]UseOCL=false
+[StrategyProperty]METHOD_OPTIONS_KEY=METHOD_EXPAND
+[StrategyProperty]USER_TACLETS_OPTIONS_KEY3=USER_TACLETS_OFF
+[StrategyProperty]LOOP_OPTIONS_KEY=LOOP_INVARIANT
+[StrategyProperty]USER_TACLETS_OPTIONS_KEY2=USER_TACLETS_OFF
+[StrategyProperty]USER_TACLETS_OPTIONS_KEY1=USER_TACLETS_OFF
+[SimultaneousUpdateSimplifier]DeleteEffectLessLocations=false
+[StrategyProperty]QUANTIFIERS_OPTIONS_KEY=QUANTIFIERS_NON_SPLITTING_WITH_PROGS
+[StrategyProperty]NON_LIN_ARITH_OPTIONS_KEY=NON_LIN_ARITH_NONE
+[DecisionProcedure]Timeout=60
+[View]ShowWholeTaclet=false
+[General]ProofAssistant=false
+[View]MaxTooltipLines=40
+[General]DnDDirectionSensitive=true
+[SimultaneousUpdateSimplifier]EagerSimplification=true
+[General]StupidMode=true
+[Strategy]Timeout=-1
+[Strategy]MaximumNumberOfAutomaticApplications=1000
+[Libraries]Default=acc.key-false, stringRules.key-false, /home/mbender/.key/libraries/stringRules.key-false, /home/mbender/.key/libraries/deprecatedRules.key-false, deprecatedRules.key-false, /home/mbender/.key/libraries/acc.key-false
+[StrategyProperty]QUERY_OPTIONS_KEY=QUERY_NONE
+[Choice]DefaultChoices=transactions-transactions\:transactionsOn , throughout-throughout\:toutOn , assertions-assertions\:on , programRules-programRules\:Java , intRules-intRules\:arithmeticSemanticsIgnoringOF , initialisation-initialisation\:disableStaticInitialisation , transactionAbort-transactionAbort\:abortOn , nullPointerPolicy-nullPointerPolicy\:nullCheck , javacard-javacard\:jcOff
+[StrategyProperty]STOPMODE_OPTIONS_KEY=STOPMODE_DEFAULT
+[DecisionProcedure]ActiveRule=_noname_
+[General]UseJML=true
+[View]HideClosedSubtrees=false
+[Choice]Choices=transactions-transactions\:transactionsOn-transactions\:transactionsOff , throughout-throughout\:toutOn-throughout\:toutOff , assertions-assertions\:on-assertions\:off-assertions\:safe , programRules-programRules\:Java-programRules\:ODL , intRules-intRules\:javaSemantics-intRules\:arithmeticSemanticsIgnoringOF-intRules\:arithmeticSemanticsCheckingOF , initialisation-initialisation\:enableStaticInitialisation-initialisation\:disableStaticInitialisation , transactionAbort-transactionAbort\:abortOn-transactionAbort\:abortOff , nullPointerPolicy-nullPointerPolicy\:noNullCheck-nullPointerPolicy\:nullCheck , javacard-javacard\:jcOff-javacard\:jcOn
+[View]HideIntermediateProofsteps=true
+[Strategy]ActiveStrategy=JavaCardDLStrategy
+[StrategyProperty]SPLITTING_OPTIONS_KEY=SPLITTING_DELAYED
+"
+}
+
+\javaSource "/home/mbender/key/examples/_testcase/testgen";
+
+
+
+\programVariables {
+java.lang.Throwable exc;
+BranchingLoop self;
+int n;
+int _n;
+}
+
+\functions {
+}
+
+\predicates {
+}
+
+\problem {
+     inReachableState
+   & (  self.<created>@(java.lang.Object) = TRUE
+      & !self = null)
+   & inInt(n)
+-> {_n:=n}
+     \[{
+         exc=null;try {
+           self.doIt(_n)@BranchingLoop;
+         }  catch (java.lang.Throwable e) {
+           exc=e;
+         }
+       }\] exc = null
+
+}
+
+\proof {
+(keyLog "0" (keyUser "mbender" ) (keyVersion "71085a7e94178c042664bf11a1e5cd6d3dbbff64"))
+
+(autoModeTime "4046")
+
+(branch "dummy ID"
+(rule "inInt" (formula "1") (term "1,0"))
+(rule "concrete_and_3" (formula "1") (term "0"))
+(rule "impRight" (formula "1"))
+(rule "andLeft" (formula "1"))
+(rule "andLeft" (formula "2"))
+(rule "notLeft" (formula "3"))
+(rule "assignment" (formula "4") (term "1"))
+(builtin "Update Simplification" (formula "4"))
+(rule "methodBodyExpand" (formula "4") (term "2"))
+(rule "variableDeclarationAssign" (formula "4") (term "2"))
+(rule "variableDeclaration" (formula "4") (term "2") (newnames "i"))
+(rule "assignment" (formula "4") (term "2"))
+(builtin "Update Simplification" (formula "4"))
+(rule "variableDeclarationAssign" (formula "4") (term "3"))
+(rule "variableDeclaration" (formula "4") (term "3") (newnames "oldN"))
+(rule "assignment" (formula "4") (term "3"))
+(builtin "Update Simplification" (formula "4"))
+(rule "whileInvBox" (formula "4") (newnames "i_0,_n_0,i_1,_n_1,anon_0") (inst "inv=    (jint)(javaDivInt((jint)(javaAddInt(i, (jint)(4))),
+                      (jint)(javaSubInt((jint)(javaAddInt((jint)(1),
+                                                          _n)),
+                                        oldN))))
+  = (jint)(4)
+& inReachableState") (inst "#v1=b") (inst "#modifies={i,_n}"))
+(branch " Invariant Initially Valid"
+   (builtin "Update Simplification" (formula "4"))
+   (rule "castDelInt" (formula "4") (term "0,0,0,0,1,0,0,0"))
+   (rule "castDelInt" (formula "4") (term "1,0"))
+   (rule "castDelInt" (formula "4") (term "0,0,0,0"))
+   (rule "castDelInt" (formula "4") (term "1,0,0,0"))
+   (rule "castDelInt" (formula "4") (term "1,0,0,0,0"))
+   (rule "castDelInt" (formula "4") (term "0,0,0,0,0"))
+   (rule "castDelInt" (formula "4") (term "0,1,0,0,0"))
+   (rule "castDelInt" (formula "4") (term "0,0"))
+   (rule "translateJavaAddInt" (formula "4") (term "0,1,0,0"))
+   (rule "translateJavaAddInt" (formula "4") (term "0,0,0"))
+   (rule "add_zero_left" (formula "4") (term "0,0,0"))
+   (rule "translateJavaSubInt" (formula "4") (term "1,0,0"))
+   (rule "translateJavaDivInt" (formula "4") (term "0,0"))
+   (rule "polySimp_elimSub" (formula "4") (term "1,0,0"))
+   (rule "polySimp_pullOutFactor1b" (formula "4") (term "1,0,0"))
+   (rule "add_literals" (formula "4") (term "1,1,1,0,0"))
+   (rule "times_zero_1" (formula "4") (term "1,1,0,0"))
+   (rule "add_zero_right" (formula "4") (term "1,0,0"))
+   (rule "jdiv_axiom_inline" (formula "4") (term "0,0"))
+   (rule "qeq_literals" (formula "4") (term "0,0,0"))
+   (rule "ifthenelse_true" (formula "4") (term "0,0"))
+   (rule "div_literals" (formula "4") (term "0,0"))
+   (rule "eqClose" (formula "4") (term "0"))
+   (rule "concrete_and_1" (formula "4"))
+   (rule "inReachableStateRewrite" (formula "4") (ifseqformula "1"))
+   (builtin "Update Simplification" (formula "4"))
+   (rule "eq_imp" (formula "4") (term "0,1"))
+   (rule "orRight" (formula "4"))
+   (rule "allRight" (formula "5") (inst "sk=o_0"))
+   (rule "closeTrue" (formula "5"))
+)
+(branch " Body Preserves Invariant"
+   (builtin "Update Simplification" (formula "4"))
+   (rule "concrete_impl_1" (formula "4"))
+   (rule "impRight" (formula "4"))
+   (rule "andLeft" (formula "1"))
+   (rule "impRight" (formula "6"))
+   (rule "andLeft" (formula "3"))
+   (rule "castDelInt" (formula "8") (term "0,0,0,0,1,0,0,0,1,1,1,0,4"))
+   (rule "castDelInt" (formula "8") (term "1,0,1,1,1,0,4"))
+   (rule "castDelInt" (formula "8") (term "0,0,0,0,1,1,1,0,4"))
+   (rule "castDelInt" (formula "3") (term "0,0,0"))
+   (rule "castDelInt" (formula "3") (term "0,0,0,0,1,0,0"))
+   (rule "castDelInt" (formula "3") (term "1"))
+   (rule "castDelInt" (formula "8") (term "0,0,1,0,0,0,1,1,1,0,4"))
+   (rule "castDelInt" (formula "8") (term "1,0,0,0,0,1,1,1,0,4"))
+   (rule "castDelInt" (formula "3") (term "1,0,0,0"))
+   (rule "castDelInt" (formula "3") (term "1,0,0"))
+   (rule "castDelInt" (formula "8") (term "1,0,0,0,1,1,1,0,4"))
+   (rule "castDelInt" (formula "3") (term "0"))
+   (rule "castDelInt" (formula "8") (term "0,0,1,1,1,0,4"))
+   (rule "castDelInt" (formula "3") (term "0,1,0"))
+   (rule "translateJavaAddInt" (formula "3") (term "0,0"))
+   (rule "translateJavaSubInt" (formula "8") (term "1,0,0,1,1,1,0,4"))
+   (rule "translateJavaAddInt" (formula "8") (term "0,0,0,1,1,1,0,4"))
+   (rule "translateJavaSubInt" (formula "3") (term "1,0"))
+   (rule "translateJavaAddInt" (formula "8") (term "0,1,0,0,1,1,1,0,4"))
+   (rule "translateJavaDivInt" (formula "3") (term "0"))
+   (rule "translateJavaDivInt" (formula "8") (term "0,0,1,1,1,0,4"))
+   (rule "translateJavaAddInt" (formula "3") (term "0,1,0"))
+   (rule "polySimp_elimSub" (formula "8") (term "1,0,0,1,1,1,0,4"))
+   (rule "polySimp_elimSub" (formula "3") (term "1,0"))
+   (rule "polySimp_addComm0" (formula "3") (term "0,0"))
+   (rule "polySimp_addComm0" (formula "8") (term "0,0,0,1,1,1,0,4"))
+   (rule "inReachableStateExpand" (formula "4"))
+   (builtin "Update Simplification" (formula "4"))
+   (rule "eq_imp" (formula "4") (term "0,1"))
+   (rule "replace_known_left" (formula "4") (term "0") (ifseqformula "5"))
+   (rule "concrete_impl_1" (formula "4"))
+   (rule "all_unused" (formula "4"))
+   (rule "true_left" (formula "4"))
+   (rule "variableDeclarationAssign" (formula "1") (term "4"))
+   (rule "variableDeclarationAssign" (formula "7") (term "4"))
+   (rule "variableDeclaration" (formula "1") (term "4") (newnames "b"))
+   (rule "variableDeclaration" (formula "7") (term "4") (newnames "exc_1"))
+   (rule "compound_less_than_comparison_2" (formula "1") (term "4") (inst "#v1=j_1") (inst "#v0=j"))
+   (rule "assignment" (formula "7") (term "4"))
+   (builtin "Update Simplification" (formula "7"))
+   (rule "variableDeclarationAssign" (formula "1") (term "4"))
+   (rule "variableDeclaration" (formula "7") (term "5") (newnames "thrownExc"))
+   (rule "variableDeclaration" (formula "1") (term "4") (newnames "j"))
+   (rule "assignment" (formula "1") (term "4"))
+   (builtin "Update Simplification" (formula "1"))
+   (rule "variableDeclarationAssign" (formula "1") (term "5"))
+   (rule "variableDeclaration" (formula "1") (term "5") (newnames "j_3"))
+   (rule "assignmentMultiplicationInt" (formula "1") (term "5"))
+   (builtin "Update Simplification" (formula "1"))
+   (rule "translateJavaMulInt" (formula "1") (term "4"))
+   (rule "less_than_comparison_new" (formula "1") (term "6"))
+   (builtin "Update Simplification" (formula "1"))
+   (rule "castDelInt" (formula "1") (term "1,0"))
+   (rule "inEqSimp_ltToLeq" (formula "1") (term "0"))
+   (rule "polySimp_mulAssoc" (formula "1") (term "1,0,0,0"))
+   (rule "polySimp_mulComm0" (formula "1") (term "0,1,0,0,0"))
+   (rule "polySimp_mulLiterals" (formula "1") (term "1,0,0,0"))
+   (rule "inEqSimp_sepPosMonomial0" (formula "1") (term "0"))
+   (rule "polySimp_mulComm0" (formula "1") (term "1,0"))
+   (rule "polySimp_rightDist" (formula "1") (term "1,0"))
+   (rule "mul_literals" (formula "1") (term "0,1,0"))
+   (rule "polySimp_mulLiterals" (formula "1") (term "1,1,0"))
+   (rule "ifUnfold" (formula "7") (term "5") (inst "#boolv=b"))
+   (rule "variableDeclaration" (formula "7") (term "5") (newnames "b_2"))
+   (rule "compound_less_than_comparison_2" (formula "7") (term "5") (inst "#v1=j_1") (inst "#v0=j"))
+   (rule "variableDeclarationAssign" (formula "7") (term "5"))
+   (rule "variableDeclaration" (formula "7") (term "5") (newnames "j_4"))
+   (rule "assignment" (formula "7") (term "5"))
+   (builtin "Update Simplification" (formula "7"))
+   (rule "variableDeclarationAssign" (formula "7") (term "6"))
+   (rule "variableDeclaration" (formula "7") (term "6") (newnames "j_5"))
+   (rule "assignmentMultiplicationInt" (formula "7") (term "6"))
+   (builtin "Update Simplification" (formula "7"))
+   (rule "translateJavaMulInt" (formula "7") (term "5"))
+   (rule "less_than_comparison_new" (formula "7") (term "7"))
+   (builtin "Update Simplification" (formula "7"))
+   (rule "castDelInt" (formula "7") (term "1,0"))
+   (rule "inEqSimp_ltToLeq" (formula "7") (term "0"))
+   (rule "polySimp_mulAssoc" (formula "7") (term "1,0,0,0"))
+   (rule "polySimp_mulComm0" (formula "7") (term "0,1,0,0,0"))
+   (rule "polySimp_mulLiterals" (formula "7") (term "1,0,0,0"))
+   (rule "inEqSimp_sepPosMonomial0" (formula "7") (term "0"))
+   (rule "polySimp_mulComm0" (formula "7") (term "1,0"))
+   (rule "polySimp_rightDist" (formula "7") (term "1,0"))
+   (rule "polySimp_mulLiterals" (formula "7") (term "1,1,0"))
+   (rule "mul_literals" (formula "7") (term "0,1,0"))
+   (rule "ifthenelse_split_for" (formula "1"))
+   (branch " i_0 <= -1 + _n_0 * 2 TRUE"
+      (rule "replace_known_left" (formula "8") (term "0") (ifseqformula "1"))
+      (rule "ifthenelse_true_for" (formula "8"))
+      (rule "ifEnterThen" (formula "8") (term "7"))
+      (rule "assignment" (formula "2") (term "6"))
+      (builtin "Update Simplification" (formula "2"))
+      (rule "assignment" (formula "8") (term "7"))
+      (builtin "Update Simplification" (formula "8"))
+      (rule "methodCallEmpty" (formula "2") (term "7"))
+      (rule "compound_assignment_op_plus" (formula "8") (term "8"))
+      (rule "emptyModality" (formula "2") (term "7"))
+      (builtin "Update Simplification" (formula "2"))
+      (rule "boolean_equal" (formula "2"))
+      (rule "true_left" (formula "2"))
+      (rule "compound_int_cast_expression" (formula "7") (term "8") (inst "#v=j"))
+      (rule "variableDeclarationAssign" (formula "7") (term "8"))
+      (rule "variableDeclaration" (formula "7") (term "8") (newnames "j_6"))
+      (rule "remove_parentheses_right" (formula "7") (term "8"))
+      (rule "compound_addition_2" (formula "7") (term "8") (inst "#v1=j_8") (inst "#v0=j_7"))
+      (rule "variableDeclarationAssign" (formula "7") (term "8"))
+      (rule "variableDeclaration" (formula "7") (term "8") (newnames "j_7"))
+      (rule "assignment" (formula "7") (term "8"))
+      (builtin "Update Simplification" (formula "7"))
+      (rule "variableDeclarationAssign" (formula "7") (term "9"))
+      (rule "variableDeclaration" (formula "7") (term "9") (newnames "j_8"))
+      (rule "remove_parentheses_right" (formula "7") (term "9"))
+      (rule "assignment" (formula "7") (term "9"))
+      (builtin "Update Simplification" (formula "7"))
+      (rule "assignmentAdditionInt" (formula "7") (term "10"))
+      (builtin "Update Simplification" (formula "7"))
+      (rule "castDelInt" (formula "7") (term "1,7"))
+      (rule "translateJavaAddInt" (formula "7") (term "7"))
+      (rule "polySimp_addComm0" (formula "7") (term "7"))
+      (rule "widening_identity_cast_5" (formula "7") (term "11"))
+      (rule "assignment" (formula "7") (term "11"))
+      (builtin "Update Simplification" (formula "7"))
+      (rule "castDelInt" (formula "7") (term "0"))
+      (rule "ifUnfold" (formula "7") (term "11") (inst "#boolv=b"))
+      (rule "variableDeclaration" (formula "7") (term "11") (newnames "b_3"))
+      (rule "greater_equal_than_comparison_new" (formula "7") (term "11"))
+      (builtin "Update Simplification" (formula "7"))
+      (rule "ifthenelse_split_for" (formula "7"))
+      (branch " i_0 >= 64 TRUE"
+         (rule "inEqSimp_exactShadow3" (formula "1") (ifseqformula "2"))
+         (rule "mul_literals" (formula "1") (term "0,0"))
+         (rule "polySimp_addAssoc" (formula "1") (term "0"))
+         (rule "add_literals" (formula "1") (term "0,0"))
+         (rule "inEqSimp_sepPosMonomial1" (formula "1"))
+         (rule "mul_literals" (formula "1") (term "1"))
+         (rule "elimGcdGeq_antec" (formula "1") (inst "elimGcdRightDiv=33") (inst "elimGcdLeftDiv=_n_0") (inst "elimGcd=2"))
+         (rule "polySimp_mulLiterals" (formula "1") (term "1,0,1,0"))
+         (rule "leq_literals" (formula "1") (term "0,0"))
+         (rule "concrete_or_2" (formula "1") (term "0"))
+         (rule "mul_literals" (formula "1") (term "0,1,0,0,0,0,0"))
+         (rule "mul_literals" (formula "1") (term "1,0,0,0,0,0"))
+         (rule "polySimp_addLiterals" (formula "1") (term "0,0,0,0"))
+         (rule "add_literals" (formula "1") (term "0,0,0,0"))
+         (rule "polySimp_pullOutFactor0b" (formula "1") (term "0,0"))
+         (rule "add_literals" (formula "1") (term "1,1,0,0"))
+         (rule "times_zero_1" (formula "1") (term "1,0,0"))
+         (rule "add_zero_right" (formula "1") (term "0,0"))
+         (rule "leq_literals" (formula "1") (term "0"))
+         (rule "concrete_or_2" (formula "1"))
+         (rule "ifEnterThen" (formula "9") (term "11"))
+         (rule "assignment" (formula "9") (term "11"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "methodCallWithinClass" (formula "9") (term "12"))
+         (rule "variableDeclarationAssign" (formula "9") (term "12"))
+         (rule "variableDeclaration" (formula "9") (term "12") (newnames "n_1"))
+         (rule "assignment" (formula "9") (term "12"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "castDelInt" (formula "9") (term "11"))
+         (rule "methodBodyExpand" (formula "9") (term "13"))
+         (rule "methodCallEmpty" (formula "9") (term "13"))
+         (rule "blockEmpty" (formula "9") (term "13"))
+         (rule "compound_assignment_op_plus" (formula "9") (term "13"))
+         (rule "compound_int_cast_expression" (formula "9") (term "13") (inst "#v=j"))
+         (rule "variableDeclarationAssign" (formula "9") (term "13"))
+         (rule "variableDeclaration" (formula "9") (term "13") (newnames "j_12"))
+         (rule "remove_parentheses_right" (formula "9") (term "13"))
+         (rule "compound_addition_2" (formula "9") (term "13") (inst "#v1=j_14") (inst "#v0=j_13"))
+         (rule "variableDeclarationAssign" (formula "9") (term "13"))
+         (rule "variableDeclaration" (formula "9") (term "13") (newnames "j_13"))
+         (rule "assignment" (formula "9") (term "13"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "variableDeclarationAssign" (formula "9") (term "14"))
+         (rule "variableDeclaration" (formula "9") (term "14") (newnames "j_14"))
+         (rule "remove_parentheses_right" (formula "9") (term "14"))
+         (rule "assignment" (formula "9") (term "14"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "assignmentAdditionInt" (formula "9") (term "15"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "castDelInt" (formula "9") (term "1,6"))
+         (rule "translateJavaAddInt" (formula "9") (term "6"))
+         (rule "polySimp_addComm0" (formula "9") (term "6"))
+         (rule "widening_identity_cast_5" (formula "9") (term "16"))
+         (rule "assignment" (formula "9") (term "16"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "castDelInt" (formula "9") (term "5"))
+         (rule "tryEmpty" (formula "9") (term "16"))
+         (rule "methodCallEmpty" (formula "9") (term "16"))
+         (rule "emptyModality" (formula "9") (term "16"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "boolean_not_equal_2" (formula "9") (term "0,0"))
+         (rule "boolean_not_equal_2" (formula "9") (term "0,0,1"))
+         (rule "concrete_impl_2" (formula "9") (term "0"))
+         (rule "concrete_not_2" (formula "9") (term "0,1"))
+         (rule "concrete_and_1" (formula "9"))
+         (rule "concrete_impl_1" (formula "9"))
+         (rule "castDelInt" (formula "9") (term "1,0,1,0,0,1"))
+         (rule "castDelInt" (formula "9") (term "1,0,0,0,1"))
+         (rule "polySimp_addAssoc" (formula "9") (term "0,1,0,0,1"))
+         (rule "add_literals" (formula "9") (term "0,0,1,0,0,1"))
+         (rule "polySimp_addAssoc" (formula "9") (term "0,0,0,1"))
+         (rule "add_literals" (formula "9") (term "0,0,0,0,1"))
+         (rule "inReachableStateRewrite" (formula "9") (term "1,1") (ifseqformula "6"))
+         (builtin "Update Simplification" (formula "9"))
+         (rule "eq_imp" (formula "9") (term "0,1,1,1"))
+         (rule "all_unused" (formula "9") (term "1,1,1"))
+         (rule "concrete_or_3" (formula "9") (term "1,1"))
+         (rule "concrete_and_3" (formula "9") (term "1"))
+         (rule "cut_direct" (formula "9") (term "1"))
+         (branch " CUT: jdiv(12 + i_0, 3 + _n_0 + n * -1) = 4 TRUE"
+            (rule "concrete_and_3" (formula "10"))
+            (opengoal "     inReachableState    & (  self.<created>@(java.lang.Object) = TRUE       & !self = null)    & inInt(n) -> {_n:=n}      \\[{          exc=null;try {            self.doIt(_n)@BranchingLoop;          }  catch (java.lang.Throwable e) {            exc=e;          }        }\\] exc = null ")
+         )
+         (branch " CUT: jdiv(12 + i_0, 3 + _n_0 + n * -1) = 4 FALSE"
+            (rule "concrete_and_4" (formula "10"))
+            (rule "false_right" (formula "10"))
+            (opengoal "     inReachableState    & (  self.<created>@(java.lang.Object) = TRUE       & !self = null)    & inInt(n) -> {_n:=n}      \\[{          exc=null;try {            self.doIt(_n)@BranchingLoop;          }  catch (java.lang.Throwable e) {            exc=e;          }        }\\] exc = null ")
+         )
+      )
+      (branch " i_0 >= 64 FALSE"
+         (rule "inEqSimp_geqRight" (formula "7"))
+         (rule "mul_literals" (formula "1") (term "1,0,0"))
+         (rule "add_literals" (formula "1") (term "0,0"))
+         (rule "inEqSimp_sepPosMonomial0" (formula "1"))
+         (rule "mul_literals" (formula "1") (term "1"))
+         (rule "ifSkipThen" (formula "8") (term "11"))
+         (rule "assignment" (formula "8") (term "11"))
+         (builtin "Update Simplification" (formula "8"))
+         (rule "compound_assignment_op_plus" (formula "8") (term "12"))
+         (rule "compound_int_cast_expression" (formula "8") (term "12") (inst "#v=j"))
+         (rule "variableDeclarationAssign" (formula "8") (term "12"))
+         (rule "variableDeclaration" (formula "8") (term "12") (newnames "j_9"))
+         (rule "remove_parentheses_right" (formula "8") (term "12"))
+         (rule "compound_addition_2" (formula "8") (term "12") (inst "#v1=j_11") (inst "#v0=j_10"))
+         (rule "variableDeclarationAssign" (formula "8") (term "12"))
+         (rule "variableDeclaration" (formula "8") (term "12") (newnames "j_10"))
+         (rule "assignment" (formula "8") (term "12"))
+         (builtin "Update Simplification" (formula "8"))
+         (rule "variableDeclarationAssign" (formula "8") (term "13"))
+         (rule "variableDeclaration" (formula "8") (term "13") (newnames "j_11"))
+         (rule "remove_parentheses_right" (formula "8") (term "13"))
+         (rule "assignment" (formula "8") (term "13"))
+         (builtin "Update Simplification" (formula "8"))
+         (rule "assignmentAdditionInt" (formula "8") (term "14"))
+         (builtin "Update Simplification" (formula "8"))
+         (rule "castDelInt" (formula "8") (term "1,13"))
+         (rule "translateJavaAddInt" (formula "8") (term "13"))
+         (rule "polySimp_addComm0" (formula "8") (term "13"))
+         (rule "widening_identity_cast_5" (formula "8") (term "15"))
+         (rule "assignment" (formula "8") (term "15"))
+         (builtin "Update Simplification" (formula "8"))
+         (rule "castDelInt" (formula "8") (term "5"))
+         (rule "tryEmpty" (formula "8") (term "15"))
+         (rule "methodCallEmpty" (formula "8") (term "15"))
+         (rule "emptyModality" (formula "8") (term "15"))
+         (builtin "Update Simplification" (formula "8"))
+         (rule "boolean_not_equal_2" (formula "8") (term "0,0"))
+         (rule "boolean_not_equal_2" (formula "8") (term "0,0,1"))
+         (rule "concrete_impl_2" (formula "8") (term "0"))
+         (rule "concrete_not_2" (formula "8") (term "0,1"))
+         (rule "concrete_and_1" (formula "8"))
+         (rule "concrete_impl_1" (formula "8"))
+         (rule "castDelInt" (formula "8") (term "1,0,1,0,0,1"))
+         (rule "castDelInt" (formula "8") (term "1,0,0,0,1"))
+         (rule "polySimp_addAssoc" (formula "8") (term "0,1,0,0,1"))
+         (rule "add_literals" (formula "8") (term "0,0,1,0,0,1"))
+         (rule "polySimp_addAssoc" (formula "8") (term "0,0,0,1"))
+         (rule "add_literals" (formula "8") (term "0,0,0,0,1"))
+         (rule "inReachableStateRewrite" (formula "8") (term "1,1") (ifseqformula "5"))
+         (builtin "Update Simplification" (formula "8"))
+         (rule "eq_imp" (formula "8") (term "0,1,1,1"))
+         (rule "all_unused" (formula "8") (term "1,1,1"))
+         (rule "concrete_or_3" (formula "8") (term "1,1"))
+         (rule "concrete_and_3" (formula "8") (term "1"))
+         (rule "cut_direct" (formula "8") (term "1"))
+         (branch " CUT: jdiv(12 + i_0, 3 + _n_0 + n * -1) = 4 TRUE"
+            (rule "concrete_and_3" (formula "9"))
+            (opengoal "     inReachableState    & (  self.<created>@(java.lang.Object) = TRUE       & !self = null)    & inInt(n) -> {_n:=n}      \\[{          exc=null;try {            self.doIt(_n)@BranchingLoop;          }  catch (java.lang.Throwable e) {            exc=e;          }        }\\] exc = null ")
+         )
+         (branch " CUT: jdiv(12 + i_0, 3 + _n_0 + n * -1) = 4 FALSE"
+            (rule "concrete_and_4" (formula "9"))
+            (rule "false_right" (formula "9"))
+            (opengoal "     inReachableState    & (  self.<created>@(java.lang.Object) = TRUE       & !self = null)    & inInt(n) -> {_n:=n}      \\[{          exc=null;try {            self.doIt(_n)@BranchingLoop;          }  catch (java.lang.Throwable e) {            exc=e;          }        }\\] exc = null ")
+         )
+      )
+   )
+   (branch " i_0 <= -1 + _n_0 * 2 FALSE"
+      (rule "replace_known_right" (formula "8") (term "0") (ifseqformula "6"))
+      (rule "ifthenelse_false_for" (formula "8"))
+      (rule "inEqSimp_leqRight" (formula "6"))
+      (rule "polySimp_rightDist" (formula "1") (term "1,0,0"))
+      (rule "mul_literals" (formula "1") (term "0,1,0,0"))
+      (rule "polySimp_mulLiterals" (formula "1") (term "1,1,0,0"))
+      (rule "polySimp_addAssoc" (formula "1") (term "0,0"))
+      (rule "add_literals" (formula "1") (term "0,0,0"))
+      (rule "add_zero_left" (formula "1") (term "0,0"))
+      (rule "inEqSimp_sepPosMonomial1" (formula "1"))
+      (rule "polySimp_mulLiterals" (formula "1") (term "1"))
+      (rule "ifSkipThen" (formula "8") (term "7"))
+      (rule "assignment" (formula "2") (term "6"))
+      (builtin "Update Simplification" (formula "2"))
+      (rule "assignment" (formula "8") (term "7"))
+      (builtin "Update Simplification" (formula "8"))
+      (rule "methodCallEmpty" (formula "2") (term "7"))
+      (rule "tryEmpty" (formula "8") (term "8"))
+      (rule "emptyModality" (formula "2") (term "7"))
+      (builtin "Update Simplification" (formula "2"))
+      (rule "boolean_not_equal_2" (formula "2"))
+      (rule "closeFalse" (formula "2"))
+   )
+)
+(branch " Use Case"
+   (rule "false_to_not_true" (formula "4") (term "0,0,1,2,4"))
+   (builtin "Update Simplification" (formula "4"))
+   (rule "impRight" (formula "4"))
+   (rule "andLeft" (formula "1"))
+   (rule "castDelInt" (formula "1") (term "0,0,0,0,1,0,0"))
+   (rule "castDelInt" (formula "1") (term "1,0,0,0,0"))
+   (rule "castDelInt" (formula "1") (term "1"))
+   (rule "castDelInt" (formula "1") (term "1,0,0"))
+   (rule "castDelInt" (formula "1") (term "0,0,0"))
+   (rule "castDelInt" (formula "1") (term "0,1,0,0"))
+   (rule "castDelInt" (formula "1") (term "0"))
+   (rule "translateJavaAddInt" (formula "1") (term "0,0"))
+   (rule "translateJavaAddInt" (formula "1") (term "0,1,0"))
+   (rule "translateJavaDivInt" (formula "1") (term "0"))
+   (rule "translateJavaSubInt" (formula "1") (term "1,0"))
+   (rule "polySimp_elimSub" (formula "1") (term "1,0"))
+   (rule "polySimp_addComm0" (formula "1") (term "0,0"))
+   (rule "inReachableStateExpand" (formula "2"))
+   (builtin "Update Simplification" (formula "2"))
+   (rule "eq_imp" (formula "2") (term "0,1"))
+   (rule "replace_known_left" (formula "2") (term "0") (ifseqformula "3"))
+   (rule "concrete_impl_1" (formula "2"))
+   (rule "all_unused" (formula "2"))
+   (rule "true_left" (formula "2"))
+   (rule "variableDeclarationAssign" (formula "5") (term "4"))
+   (rule "variableDeclaration" (formula "5") (term "4") (newnames "b_1"))
+   (rule "compound_less_than_comparison_2" (formula "5") (term "4") (inst "#v1=j_1") (inst "#v0=j"))
+   (rule "variableDeclarationAssign" (formula "5") (term "4"))
+   (rule "variableDeclaration" (formula "5") (term "4") (newnames "j_2"))
+   (rule "assignment" (formula "5") (term "4"))
+   (builtin "Update Simplification" (formula "5"))
+   (rule "variableDeclarationAssign" (formula "5") (term "5"))
+   (rule "variableDeclaration" (formula "5") (term "5") (newnames "j_1"))
+   (rule "assignmentMultiplicationInt" (formula "5") (term "5"))
+   (builtin "Update Simplification" (formula "5"))
+   (rule "translateJavaMulInt" (formula "5") (term "3"))
+   (rule "less_than_comparison_new" (formula "5") (term "6"))
+   (builtin "Update Simplification" (formula "5"))
+   (rule "castDelInt" (formula "5") (term "1,0"))
+   (rule "inEqSimp_ltToLeq" (formula "5") (term "0"))
+   (rule "polySimp_mulAssoc" (formula "5") (term "1,0,0,0"))
+   (rule "polySimp_mulComm0" (formula "5") (term "0,1,0,0,0"))
+   (rule "polySimp_mulLiterals" (formula "5") (term "1,0,0,0"))
+   (rule "inEqSimp_sepPosMonomial0" (formula "5") (term "0"))
+   (rule "polySimp_mulComm0" (formula "5") (term "1,0"))
+   (rule "polySimp_rightDist" (formula "5") (term "1,0"))
+   (rule "mul_literals" (formula "5") (term "0,1,0"))
+   (rule "polySimp_mulLiterals" (formula "5") (term "1,1,0"))
+   (rule "ifthenelse_split_for" (formula "5"))
+   (branch " i_1 <= -1 + _n_1 * 2 TRUE"
+      (rule "assignment" (formula "6") (term "6"))
+      (builtin "Update Simplification" (formula "6"))
+      (rule "methodCallEmpty" (formula "6") (term "7"))
+      (rule "emptyModality" (formula "6") (term "7"))
+      (builtin "Update Simplification" (formula "6"))
+      (rule "boolean_equal" (formula "6") (term "0,0"))
+      (rule "concrete_not_1" (formula "6") (term "0"))
+      (rule "concrete_impl_2" (formula "6"))
+      (rule "closeTrue" (formula "6"))
+   )
+   (branch " i_1 <= -1 + _n_1 * 2 FALSE"
+      (rule "inEqSimp_leqRight" (formula "5"))
+      (rule "polySimp_rightDist" (formula "1") (term "1,0,0"))
+      (rule "mul_literals" (formula "1") (term "0,1,0,0"))
+      (rule "polySimp_mulLiterals" (formula "1") (term "1,1,0,0"))
+      (rule "polySimp_addAssoc" (formula "1") (term "0,0"))
+      (rule "add_literals" (formula "1") (term "0,0,0"))
+      (rule "add_zero_left" (formula "1") (term "0,0"))
+      (rule "inEqSimp_sepPosMonomial1" (formula "1"))
+      (rule "polySimp_mulLiterals" (formula "1") (term "1"))
+      (rule "assignment" (formula "6") (term "6"))
+      (builtin "Update Simplification" (formula "6"))
+      (rule "methodCallEmpty" (formula "6") (term "7"))
+      (rule "emptyModality" (formula "6") (term "7"))
+      (builtin "Update Simplification" (formula "6"))
+      (rule "boolean_not_equal_2" (formula "6") (term "0,0"))
+      (rule "concrete_not_2" (formula "6") (term "0"))
+      (rule "concrete_impl_1" (formula "6"))
+      (rule "methodCallEmpty" (formula "6") (term "7"))
+      (rule "tryEmpty" (formula "6") (term "7"))
+      (rule "emptyModality" (formula "6") (term "7"))
+      (builtin "Update Simplification" (formula "6"))
+      (rule "eqClose" (formula "6"))
+      (rule "closeTrue" (formula "6"))
+   )
+)
+)
+
+}
diff --git a/system/de/uka/ilkd/key/gui/SimpleStarter.java b/system/de/uka/ilkd/key/gui/SimpleStarter.java
index 108ca28..7bddaa5 100644
--- a/system/de/uka/ilkd/key/gui/SimpleStarter.java
+++ b/system/de/uka/ilkd/key/gui/SimpleStarter.java
@@ -27,11 +27,16 @@ public class SimpleStarter implements IMain {
 
     private KeYMediator mediator;
     private String fileNameOnStartUp;
-    private MainTaskListenerBatchMode ptl;
+    private ProverTaskListener ptl;
 
     public SimpleStarter(String file) {
+	this.fileNameOnStartUp = file;
+        this.ptl= new MainTaskListenerBatchMode();
+    }
+    
+    public SimpleStarter(String file, ProverTaskListener ptl ) {
         this.fileNameOnStartUp = file;
-        this.ptl = new MainTaskListenerBatchMode();
+        this.ptl = ptl;
     }
     
     public void setKeYMediator(KeYMediator mediator) {
diff --git a/system/de/uka/ilkd/key/unittest/TestGenerator.java b/system/de/uka/ilkd/key/unittest/TestGenerator.java
index 5507ddd..d2aa2cd 100644
--- a/system/de/uka/ilkd/key/unittest/TestGenerator.java
+++ b/system/de/uka/ilkd/key/unittest/TestGenerator.java
@@ -18,6 +18,7 @@ import de.uka.ilkd.key.java.abstraction.*;
 import de.uka.ilkd.key.java.statement.*;
 import de.uka.ilkd.key.java.visitor.*;
 import de.uka.ilkd.key.unittest.ppAndJavaASTExtension.*;
+import de.uka.ilkd.key.unittest.testing.DataStorage;
 import de.uka.ilkd.key.util.*;
 import de.uka.ilkd.key.visualdebugger.VisualDebugger;
 import de.uka.ilkd.key.logic.*;
@@ -80,6 +81,10 @@ public class TestGenerator {
 
     // private HashMap array2length;
 
+    private DataStorage data;
+
+    private final boolean testing;
+
     /**
      * creates a TestGenerator instance for the given compilation unit
      * 
@@ -88,7 +93,9 @@ public class TestGenerator {
      * @param fileName
      *            the name of the unittest file this TestGenerator creates.
      */
-    public TestGenerator(Services serv, String fileName) {
+    public TestGenerator(Services serv, String fileName, String directory,
+	    boolean testing) {
+	this.testing = testing;
 	ji = serv.getJavaInfo();
 	translatedFormulas = new HashMap<Term, Expression>();
 	// array2length = new HashMap();
@@ -123,10 +130,6 @@ public class TestGenerator {
 	// clean typesystem for JavaCard).
 	suiteMethod = createSuiteMethod();
 	rand = new Random();
-    }
-
-    public TestGenerator(Services serv, String fileName, String directory) {
-	this(serv, fileName);
 	if (directory != null)
 	    this.directory = directory;
     }
@@ -217,6 +220,7 @@ public class TestGenerator {
 
 	// put test data in array
 	ProgramVariable[] testArray = new ProgramVariable[testLocation.length];
+
 	boolean singleTuple = singleTuple(testData);
 	for (int i = 0; i < testData.length; i++) {
 	    KeYJavaType kjt = testLocEqvs[i].getKeYJavaType();
@@ -622,6 +626,7 @@ public class TestGenerator {
 	    programVars = programVars.union(mg.getProgramVariables());
 	}
 	pvaNotDecl = removeDublicates(programVars).toArray();
+	data.setPvs2(pvaNotDecl);
 	it = mgs.iterator();
 	ExtList l = new ExtList();
 	l.add(suiteMethod);
@@ -673,6 +678,7 @@ public class TestGenerator {
 			    .getValueAsExpression(eqvArray[i]);
 		}
 	    }
+	    data.addTestDat(testData);
 	    MethodDeclaration methDec = createTestMethod(code, oracle,
 		    testLocation, testData, pvaNotDecl, methodName
 			    + (testMethods.size()), l, mg, eqvArray);
@@ -688,18 +694,21 @@ public class TestGenerator {
 	try {
 	    // write the file to disk
 	    pp.printClassDeclaration(suite);
-	    File dir = new File(directory);
-	    if (!dir.exists()) {
-		dir.mkdirs();
+	    if (!testing) {
+		File dir = new File(directory);
+		if (!dir.exists()) {
+		    dir.mkdirs();
+		}
+		File pcFile = new File(dir, fileName + ".java");
+		path = pcFile.getAbsolutePath();
+		FileWriter fw = new FileWriter(pcFile);
+		BufferedWriter bw = new BufferedWriter(fw);
+		bw.write(addImports(clean(w.toString()), pr));
+		bw.close();
 	    }
-	    File pcFile = new File(dir, fileName + ".java");
-	    path = pcFile.getAbsolutePath();
-	    FileWriter fw = new FileWriter(pcFile);
-	    BufferedWriter bw = new BufferedWriter(fw);
-	    bw.write(addImports(clean(w.toString()), pr));
-	    bw.close();
 	} catch (IOException ioe) {
 	}
+
 	exportCodeUnderTest();
     }
 
@@ -799,20 +808,23 @@ public class TestGenerator {
 			    .getPositionInfo().getFileName();
 
 		    String header = getHeader(fn);
+		    if (!testing) {
+			File dir = new File(directory
+				+ fn.substring(fn.indexOf(File.separator), fn
+					.lastIndexOf(File.separator)));
+			fn = fn.substring(fn.lastIndexOf(File.separator) + 1);
+			if (!dir.exists()) {
+			    dir.mkdirs();
+			}
+			File pcFile = new File(dir, fn);
+			FileWriter fw = new FileWriter(pcFile);
+			BufferedWriter bw = new BufferedWriter(fw);
+			bw.write(header);
+			bw.write(clean(sw.toString()));
+			bw.close();
+		    } else {
 
-		    File dir = new File(directory
-			    + fn.substring(fn.indexOf(File.separator), fn
-				    .lastIndexOf(File.separator)));
-		    fn = fn.substring(fn.lastIndexOf(File.separator) + 1);
-		    if (!dir.exists()) {
-			dir.mkdirs();
 		    }
-		    File pcFile = new File(dir, fn);
-		    FileWriter fw = new FileWriter(pcFile);
-		    BufferedWriter bw = new BufferedWriter(fw);
-		    bw.write(header);
-		    bw.write(clean(sw.toString()));
-		    bw.close();
 		} catch (IOException ioe) {
 		    throw new UnitTestException(ioe);
 		}
@@ -1332,8 +1344,7 @@ public class TestGenerator {
     /**
      * Replaces rigid constants by program variables.
      */
-    protected static Term replaceConstants(Term t, Services serv,
-	    Namespace newPVs) {
+    static Term replaceConstants(Term t, Services serv, Namespace newPVs) {
 	TermFactory tf = TermFactory.DEFAULT;
 	Term result = null;
 	if (t.op() instanceof RigidFunction && t.arity() == 0
@@ -1372,4 +1383,12 @@ public class TestGenerator {
 	return result;
     }
 
+    public DataStorage getData() {
+	return data;
+    }
+
+    public void setData(DataStorage data) {
+	this.data = data;
+    }
+
 }
diff --git a/system/de/uka/ilkd/key/unittest/TestTestGenerator.java b/system/de/uka/ilkd/key/unittest/TestTestGenerator.java
index 84aa177..80a51d9 100644
--- a/system/de/uka/ilkd/key/unittest/TestTestGenerator.java
+++ b/system/de/uka/ilkd/key/unittest/TestTestGenerator.java
@@ -13,35 +13,253 @@ import de.uka.ilkd.key.java.JavaInfo;
 import de.uka.ilkd.key.java.abstraction.KeYJavaType;
 import de.uka.ilkd.key.proof.init.Profile;
 import de.uka.ilkd.key.rule.TacletForTests;
+import de.uka.ilkd.key.unittest.testing.TestHelper;
 
 public class TestTestGenerator extends TestCase {
 
+    private static TestHelper absMin = null;
+
+    private static TestHelper brLoop = null;
+
     private JavaInfo javaInfo;
+
     private Profile old;
-    
+
     public TestTestGenerator(String name) {
-        super(name);
+	super(name);
+	if (absMin == null) {
+	    absMin = new TestHelper("absMin.key", true);
+	}
+	if (brLoop == null) {
+	    brLoop = new TestHelper("branchingLoop.proof", false);
+	}
     }
 
     public void setUp() {
 	old = ProofSettings.DEFAULT_SETTINGS.getProfile();
 	ProofSettings.DEFAULT_SETTINGS.setProfile(TacletForTests.profile);
-        TacletForTests.lastFile = null;
+	TacletForTests.lastFile = null;
 	TacletForTests.parse();
-        javaInfo = TacletForTests.getJavaInfo();
+	javaInfo = TacletForTests.getJavaInfo();
     }
-    
+
     public void tearDown() {
 	ProofSettings.DEFAULT_SETTINGS.setProfile(old);
-        TacletForTests.lastFile = null;
-        TacletForTests.parse();
+	TacletForTests.lastFile = null;
+	TacletForTests.parse();
+    }
+
+    public void testJUnitClassesAvailable() {
+	KeYJavaType testCase = javaInfo
+		.getKeYJavaTypeByClassName("junit.framework.TestCase");
+	KeYJavaType testSuite = javaInfo
+		.getKeYJavaTypeByClassName("junit.framework.TestSuite");
+	KeYJavaType stringBuffer = javaInfo
+		.getKeYJavaTypeByClassName("java.lang.StringBuffer");
+	assertTrue(testCase != null && testSuite != null
+		&& stringBuffer != null);
+    }
+
+    public void testAbsMinLoad() {
+	assertTrue(
+		"\nTestCase failed because "
+			+ absMin.getFName()
+			+ " could not be loaded."
+			+ "\nThis is not a poblem with TestGeneration but with something else.",
+		absMin.getProof() != null);
+    }
+
+    public void testBrLoopLoad() {
+	assertTrue(
+		"\nTestCase failed because "
+			+ brLoop.getFName()
+			+ " could not be loaded."
+			+ "\nThis is not a poblem with TestGeneration but with something else.",
+		brLoop.getProof() != null);
+    }
+
+    public void testAbsMinNrOfGoals() {
+	final int is = absMin.getNrofOG();
+	final int sb = 4;
+	assertTrue(
+		"\nTestCase failed because "
+			+ absMin.getFName()
+			+ " has "
+			+ is
+			+ "Open Goals instead of "
+			+ sb
+			+ "."
+			+ "\nThis is not a poblem with TestGeneration but with something else.",
+		is == sb);
+    }
+
+    public void testBrLoopNrOfGoals() {
+	final int is = brLoop.getNrofOG();
+	final int sb = 4;
+	assertTrue(
+		"\nTestCase failed because "
+			+ brLoop.getFName()
+			+ " has "
+			+ is
+			+ "Open Goals instead of "
+			+ sb
+			+ "."
+			+ "\nThis is not a poblem with TestGeneration but with something else.",
+		is == sb);
+    }
+
+    public void testAbsMinNrOfMeth() {
+	final int is = absMin.nrOfMeth();
+	final int sb = 1;
+	assertTrue("\nNr of methods of " + absMin.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+
+    }
+
+    public void testBrLoopNrOfMeth() {
+	final int is = brLoop.nrOfMeth();
+	final int sb = 2;
+	assertTrue("\nNr of methods of " + brLoop.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+
+    }
+
+    public void testAbsMinMethNames() {
+	final String is = absMin.methNames();
+	final String sb = "AbsMin::absMin";
+	assertTrue("Name of available methods of " + absMin.getFName() + " is "
+		+ is + " instead of " + sb + ".", sb.equals(is));
+    }
+
+    public void testBrLoopMethNames() {
+	final String is = brLoop.methNames();
+	final String sb = "BranchingLoop::fooBranchingLoop::doIt";
+	assertTrue("Name of available methods of " + brLoop.getFName() + " is "
+		+ is + " instead of " + sb + ".", sb.equals(is));
+    }
+
+    public void testAbsMinNrOfNodes() {
+	final int is = absMin.getNrOfNodes();
+	final int sb = 4;
+	assertTrue("\nNr of nodes of " + absMin.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+    }
+
+    public void testBrLoopNrOfNodes() {
+	final int is = brLoop.getNrOfNodes();
+	final int sb = 8;
+	assertTrue("\nNr of nodes of " + brLoop.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+    }
+
+    public void testAbsMinNrOfStatements() {
+	final int is = absMin.getNrOfStatements();
+	final int sb = 4;
+	assertTrue("\nNr of Statements of " + absMin.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+    }
+
+    public void testBrLoopNrOfStatements() {
+	final int is = brLoop.getNrOfStatements();
+	final int sb = 3;
+	assertTrue("\nNr of Statements of " + brLoop.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+    }
+
+    public void testAbsMinNrOfMGS() {
+	final int is = absMin.getNrOfMGS();
+	final int sb = 4;
+	assertTrue("\nNr of ModelGenerators of " + absMin.getFName() + " is "
+		+ is + " instead of " + sb + ".", is == sb);
     }
-    
-    public void testJUnitClassesAvailable(){
-        KeYJavaType testCase = javaInfo.getKeYJavaTypeByClassName("junit.framework.TestCase");
-        KeYJavaType testSuite = javaInfo.getKeYJavaTypeByClassName("junit.framework.TestSuite");
-        KeYJavaType stringBuffer = javaInfo.getKeYJavaTypeByClassName("java.lang.StringBuffer");
-        assertTrue(testCase!=null && testSuite!=null && stringBuffer!=null);
+
+    public void testBrLoopNrOfMGS() {
+	final int is = brLoop.getNrOfMGS();
+	final int sb = 5;
+	assertTrue("\nNr of ModelGenerators of " + brLoop.getFName() + " is "
+		+ is + " instead of " + sb + ".", is == sb);
     }
-    
+
+    public void testAbsMinOracleExists() {
+	assertTrue("\nOracle of " + absMin.getFName() + " is null", absMin
+		.isOracleNnull());
+    }
+
+    public void testBrLoopOracleExists() {
+	assertTrue("\nOracle of " + brLoop.getFName() + " is null", brLoop
+		.isOracleNnull());
+    }
+
+    public void testAbsMinNrOfPVS() {
+	final int is = absMin.getNrOfPV();
+	final int sb = 6;
+	assertTrue("\nNr of ProgramVariables of " + absMin.getFName() + " is "
+		+ is + " instead of " + sb + ".", is == sb);
+    }
+
+    public void testBrLoopNrOfPVS() {
+	final int is = brLoop.getNrOfPV();
+	final int sb = 4;
+	assertTrue("\nNr of ProgramVariables of " + brLoop.getFName() + " is "
+		+ is + " instead of " + sb + ".", is == sb);
+    }
+
+    public void testAbsMinNrOfPVS2() {
+	final int is = absMin.getNrOfPV2();
+	final int sb = 6;
+	assertTrue("\nNr of ProgramVariables in TestGenerator of "
+		+ absMin.getFName() + " is " + is + " instead of " + sb + ".",
+		is == sb);
+    }
+
+    public void testBrLoopNrOfPVS2() {
+	final int is = brLoop.getNrOfPV2();
+	final int sb = 8;
+	assertTrue("\nNr of ProgramVariables in TestGenerator of "
+		+ brLoop.getFName() + " is " + is + " instead of " + sb + ".",
+		is == sb);
+    }
+
+    public void testAbsMinNrOfTesDat() {
+	final int is = absMin.getNrOfTestDat();
+	final int sb = 4;
+	assertTrue("\nNr of Test Tuples of " + absMin.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+    }
+
+    public void testBrLoopNrOfTesDat() {
+	final int is = brLoop.getNrOfTestDat();
+	final int sb = 4;
+	assertTrue("\nNr of Test Tuples of " + brLoop.getFName() + " is " + is
+		+ " instead of " + sb + ".", is == sb);
+    }
+
+    public void testAbsMinSumOfTesDat() {
+	final int is = absMin.calcSum();
+	final int sb = 4;
+	assertTrue(
+		"\nSum of Test Tuples of "
+			+ absMin.getFName()
+			+ " is "
+			+ is
+			+ " instead of beeing at least "
+			+ sb
+			+ ".\nThis value has be guessed and might be wrong.\nHumand mind needed to solve this.",
+		is >= sb);
+    }
+
+    public void testBrLoopSumOfTesDat() {
+	final int is = brLoop.calcSum();
+	final int sb = 192;
+	assertTrue(
+		"\nSum of Test Tuples of "
+			+ brLoop.getFName()
+			+ " is "
+			+ is
+			+ " instead of beeing at least "
+			+ sb
+			+ ".\nThis value has be guessed and might be wrong.\nHumand mind needed to solve this.",
+		is >= sb);
+    }
+
 }
diff --git a/system/de/uka/ilkd/key/unittest/UnitTestBuilder.java b/system/de/uka/ilkd/key/unittest/UnitTestBuilder.java
index 86f8ff4..d401625 100644
--- a/system/de/uka/ilkd/key/unittest/UnitTestBuilder.java
+++ b/system/de/uka/ilkd/key/unittest/UnitTestBuilder.java
@@ -14,6 +14,7 @@ import de.uka.ilkd.key.java.visitor.JavaASTCollector;
 import de.uka.ilkd.key.logic.*;
 import de.uka.ilkd.key.logic.op.*;
 import de.uka.ilkd.key.proof.*;
+import de.uka.ilkd.key.unittest.testing.DataStorage;
 import de.uka.ilkd.key.visualization.*;
 
 import java.util.*;
@@ -23,18 +24,22 @@ import java.util.*;
  */
 public class UnitTestBuilder {
 
-    private HashMap<Node, ExecutionTraceModel[]> node2trace;
+    private final HashMap<Node, ExecutionTraceModel[]> node2trace;
 
-    private Services serv;
+    private final Services serv;
 
-    private Constraint uc;
+    private final Constraint uc;
 
     // the nodes containing trace ends that have already been processed by the
     // proof visualization
-    private HashSet<Node> traceEndNodes;
+    private final HashSet<Node> traceEndNodes;
 
     private PackageReference pr;
 
+    // mbender: This object is only needed to store certain values, that are
+    // needed for the KeY junit tests
+    private final DataStorage dataForTest;
+
     // private int coverage;
 
     /**
@@ -54,12 +59,20 @@ public class UnitTestBuilder {
 
     private String directory = null;
 
-    public UnitTestBuilder(Services serv, Proof p) {
+    private final boolean testing;
+
+    public UnitTestBuilder(Services serv, Proof p, boolean testing) {
 	this.serv = serv;
 	node2trace = new HashMap<Node, ExecutionTraceModel[]>();
 	uc = p.getUserConstraint().getConstraint();
 	traceEndNodes = new HashSet<Node>();
 	pvn = p.getNamespaces().programVariables();
+	dataForTest = new DataStorage();
+	this.testing = testing;
+    }
+
+    public UnitTestBuilder(Services serv, Proof p) {
+	this(serv, p, false);
     }
 
     /**
@@ -141,6 +154,7 @@ public class UnitTestBuilder {
 	    nodeCounter++;
 
 	    ExecutionTraceModel[] tr = getTraces(n);
+	    dataForTest.addETM(tr);
 
 	    statements.addAll(getStatements(tr));
 	    int maxRating = -1;
@@ -213,7 +227,7 @@ public class UnitTestBuilder {
 		    coll.start();
 		    if (coll.getNodes().size() == 0) {
 			tg = new TestGenerator(serv,
-				"Test" + tce.getFileName(), directory);
+				"Test" + tce.getFileName(), directory, testing);
 			if (methodName == null) {
 			    methodName = tce.getMethodName();
 			}
@@ -254,6 +268,14 @@ public class UnitTestBuilder {
 				    + minTraceLen + ")\n"
 				    : ""));
 	}
+	dataForTest.setPms(pms);
+	dataForTest.setNodeCount(nodeCounter);
+	dataForTest.setCode(code);
+	dataForTest.setOracle(oracle);
+	dataForTest.setMgs(mgs);
+	dataForTest.setPvs(pvs);
+	dataForTest.setTg(tg);
+	tg.setData(dataForTest);
 	// computeStatementCoverage(statements, tce.getStatements());
 	tg.generateTestSuite(code, oracle, mgs, pvs, "test" + methodName, pr);
 	return tg.getPath();
@@ -269,11 +291,11 @@ public class UnitTestBuilder {
 		getProgramMethods(tr));
     }
 
-    public String createTestForNodes(ListOfNode l){        
-	return createTestForNodes(Arrays.asList(l.toArray()).iterator(), 
-	                getProgramMethods(l));
+    public String createTestForNodes(ListOfNode l) {
+	return createTestForNodes(Arrays.asList(l.toArray()).iterator(),
+		getProgramMethods(l));
     }
-    
+
     // private void computeStatementCoverage(HashSet<Position>
     // executedStatements,
     // HashSet<Statement> sourceStatements) {
@@ -338,4 +360,8 @@ public class UnitTestBuilder {
 		.toString(), n);
     }
 
+    public DataStorage getDS() {
+	return dataForTest;
+    }
+
 }
diff --git a/system/de/uka/ilkd/key/unittest/simplify/OldSimplifyModelGenerator.java b/system/de/uka/ilkd/key/unittest/simplify/OldSimplifyModelGenerator.java
index ffd929f..d668f55 100644
--- a/system/de/uka/ilkd/key/unittest/simplify/OldSimplifyModelGenerator.java
+++ b/system/de/uka/ilkd/key/unittest/simplify/OldSimplifyModelGenerator.java
@@ -66,7 +66,7 @@ public class OldSimplifyModelGenerator implements DecProdModelGenerator {
 	try {
 	    while (it.hasNext()) {
 		de.uka.ilkd.key.logic.Term t = it.next();
-		String s = st.translate(t, v).toString();
+		String s = st.pretranslate(t, v).toString();
 		string2class.put(s, term2class.get(t));
 	    }
 	} catch (SimplifyException e) {
@@ -86,7 +86,7 @@ public class OldSimplifyModelGenerator implements DecProdModelGenerator {
 		    intClasses.add(ec);
 		    de.uka.ilkd.key.logic.Term loc = ec.getLocations()
 			    .iterator().next();
-		    String eq = "(EQ " + ph + " " + st.translate(loc, v)
+		    String eq = "(EQ " + ph + " " + st.pretranslate(loc, v)
 			    + ")\n";
 		    initialCounterExample = initialCounterExample.substring(0,
 			    index)
diff --git a/system/de/uka/ilkd/key/unittest/simplify/translation/SimplifyTranslation.java b/system/de/uka/ilkd/key/unittest/simplify/translation/SimplifyTranslation.java
index 423b9fb..a09ed64 100644
--- a/system/de/uka/ilkd/key/unittest/simplify/translation/SimplifyTranslation.java
+++ b/system/de/uka/ilkd/key/unittest/simplify/translation/SimplifyTranslation.java
@@ -19,14 +19,15 @@ import org.apache.log4j.Logger;
 
 import de.uka.ilkd.key.collection.ListOfString;
 import de.uka.ilkd.key.collection.SLListOfString;
-import de.uka.ilkd.key.gui.Main;
 import de.uka.ilkd.key.java.Services;
 import de.uka.ilkd.key.logic.ConstrainedFormula;
+import de.uka.ilkd.key.logic.Name;
 import de.uka.ilkd.key.logic.Named;
 import de.uka.ilkd.key.logic.Semisequent;
 import de.uka.ilkd.key.logic.Sequent;
 import de.uka.ilkd.key.logic.Term;
 import de.uka.ilkd.key.logic.TermFactory;
+import de.uka.ilkd.key.logic.ldt.AbstractIntegerLDT;
 import de.uka.ilkd.key.logic.op.ArrayOfQuantifiableVariable;
 import de.uka.ilkd.key.logic.op.ArrayOp;
 import de.uka.ilkd.key.logic.op.AttributeOp;
@@ -187,11 +188,15 @@ public class SimplifyTranslation {
 
     private Sort integerSort;
 
+    private AbstractIntegerLDT integerLDT;
+
     private static long counter = 0;
 
     static Logger logger = Logger
 	    .getLogger(SimplifyTranslation.class.getName());
 
+    final TermFactory tf = TermFactory.DEFAULT;
+
     /**
      * Just a constructor which starts the conversion to Simplify syntax. The
      * result can be fetched with
@@ -210,14 +215,14 @@ public class SimplifyTranslation {
 	// super(sequent, cs, localmv, services);
 	constraintSet = cs;
 	localMetavariables = localmv;
+	integerLDT = services.getTypeConverter().getIntegerLDT();
+	integerSort = integerLDT.targetSort();
 	jbyteSort = services.getTypeConverter().getByteLDT().targetSort();
 	jshortSort = services.getTypeConverter().getShortLDT().targetSort();
 	jintSort = services.getTypeConverter().getIntLDT().targetSort();
 	jlongSort = services.getTypeConverter().getLongLDT().targetSort();
 	jcharSort = services.getTypeConverter().getCharLDT().targetSort();
-	integerSort = services.getTypeConverter().getIntegerLDT().targetSort();
 	cacheForUninterpretedSymbols = new HashMap<Term, StringBuffer>();
-	String s = sequent.toString();
 	StringBuffer hb = translate(sequent, lightWeight);
 	text = predicate.toString() + produceClosure(hb);
 	logger.info("SimplifyTranslation:\n" + text);
@@ -279,68 +284,214 @@ public class SimplifyTranslation {
 	return number.intValue();
     }
 
-    /**Build a new copy of t, except that any occurence of an if-then-else term 
-     * whose if-part equals @param ifPart is replaced by the 
-     * then-part (if @param part is true) or by the 
-     * else-part (if @param part is false). 
-     * @author gladisch */
-    protected Term replaceIfThenElse(Term t, Term ifPart, boolean part){
-	TermFactory tf = TermFactory.DEFAULT;
-	
-	if(t.arity()==0){
+    /**
+     * Build a new copy of t, except that any occurence of an if-then-else term
+     * whose if-part equals @param ifPart is replaced by the then-part (if @param
+     * part is true) or by the else-part (if @param part is false).
+     * 
+     * @author gladisch
+     */
+    private Term replaceIfThenElse(Term t, Term ifPart, boolean part) {
+	if (t.arity() == 0) {
 	    return t;
 	}
-	
- 	if(ifPart.sort()!=Sort.FORMULA){
-	    throw new RuntimeException("Unexpected parameter 2\nParam1=\n"+
-		    t.toString()+"\nParam2= (sort:"+ifPart.sort()+")\n"+ifPart.toString());
+
+	if (ifPart.sort() != Sort.FORMULA) {
+	    throw new RuntimeException("Unexpected parameter 2\nParam1=\n"
+		    + t.toString() + "\nParam2= (sort:" + ifPart.sort() + ")\n"
+		    + ifPart.toString());
 	}
 
-	//Base case
-	if(t.sub(0)==ifPart){
-	    if(!(t.op() instanceof IfThenElse)){
-		    throw new RuntimeException("Unexpected parameter combination. Firs parameter should be an if-then-else term\nParam1=\n"+
-			    t.toString()+"\nParam2=\n"+ifPart.toString());
+	// Base case
+	if (t.sub(0) == ifPart) {
+	    if (!(t.op() instanceof IfThenElse)) {
+		throw new RuntimeException(
+			"Unexpected parameter combination. Firs parameter should be an if-then-else term\nParam1=\n"
+				+ t.toString()
+				+ "\nParam2=\n"
+				+ ifPart.toString());
 	    }
-	    if(part){
-		return replaceIfThenElse(t.sub(1),ifPart,part);
-	    }else{
-		return replaceIfThenElse(t.sub(2),ifPart,part);
+	    if (part) {
+		return replaceIfThenElse(t.sub(1), ifPart, part);
+	    } else {
+		return replaceIfThenElse(t.sub(2), ifPart, part);
 	    }
 	}
-	
-	//Recursive replacement
+
+	// Recursive replacement
 	Term[] subs = new Term[t.arity()];
-	for(int i=0;i<t.arity();i++){
-	    subs[i] = replaceIfThenElse(t.sub(i),ifPart,part);
-	}
-	
-	//collect bound variables
-	final ArrayOfQuantifiableVariable[] vars = 
-		new ArrayOfQuantifiableVariable[t.arity()];
-	for(int i = 0; i < t.arity(); i++) {
+	for (int i = 0; i < t.arity(); i++) {
+	    subs[i] = replaceIfThenElse(t.sub(i), ifPart, part);
+	}
+
+	// collect bound variables
+	final ArrayOfQuantifiableVariable[] vars = new ArrayOfQuantifiableVariable[t
+		.arity()];
+	for (int i = 0; i < t.arity(); i++) {
 	    vars[i] = t.varsBoundHere(i);
 	}
-	
-	//build the new term
+
+	// build the new term
 	return tf.createTerm(t.op(), subs, vars, t.javaBlock());
     }
-    
-    /**If an if-then-else term is found in t, then the if-condition of the if-then-else
-     * is returned. Otherwise null is returned. 
-     * @author gladisch */
-    protected Term findIfThenElse(Term t){
-	if((t.op() instanceof IfThenElse) && t.sort()!=Sort.FORMULA){
+
+    /**
+     * If an if-then-else term is found in t, then the if-condition of the
+     * if-then-else is returned. Otherwise null is returned.
+     * 
+     * @author gladisch
+     */
+    private Term findIfThenElse(Term t) {
+	if ((t.op() instanceof IfThenElse) && t.sort() != Sort.FORMULA) {
 	    return t.sub(0);
 	}
-	for(int i=0;i<t.arity();i++){
-	    Term res=findIfThenElse(t.sub(i));
-	    if(res!=null){
+	for (int i = 0; i < t.arity(); i++) {
+	    Term res = findIfThenElse(t.sub(i));
+	    if (res != null) {
 		return res;
 	    }
 	}
 	return null;
     }
+
+    /**
+     * If an division term is found in the formula t, then the term is returned.
+     * Otherwise null is returned.
+     * 
+     * @author mbender
+     */
+    private Term findDivIForm(Term t) {
+	Term sub;
+	Term res;
+	for (int i = 0; i < t.arity(); i++) {
+	    sub = t.sub(i);
+	    if (sub.sort() == Sort.FORMULA) {
+		if ((res = findDivIForm(sub)) != null) {
+		    return res;
+		}
+	    } else {
+		if ((res = findDivITerm(sub)) != null) {
+		    return t;
+		}
+	    }
+	}
+	return null;
+    }
+
+    /**
+     * If an division term is found in the term t, then the term is returned.
+     * Otherwise null is returned.
+     * 
+     * @author mbender
+     */
+    private Term findDivITerm(Term t) {
+	if ((t.op().equals(integerLDT.getDiv()))) {
+	    return t;
+	} else if (!(t.op().name().toString().equals(
+		AbstractIntegerLDT.NUMBERS_NAME) || t.arity() == 0)) {
+	    Term res;
+	    for (int i = 0; i < t.arity(); i++) {
+		if ((res = findDivITerm(t.sub(i))) != null) {
+		    return res;
+		}
+	    }
+	}
+	return null;
+    }
+
+    /**
+     * Build a new copy of @param term, except that any occurence of the term @param
+     * divForm is replaced by a term that equals @param divForm a variable
+     * instead of the division. Additionally a term is conjunctivly added to
+     * 'define' the value of the introduced variable. This procedure is needed
+     * to express the division through a multiplication
+     * 
+     * @author mbender
+     */
+    private Term replaceForm(Term form, Term divForm, Term divTerm, Term newVar) {
+	boolean isForm = form.equals(divForm);
+	final int l = form.arity();
+	final Term[] subs = new Term[l];
+	final ArrayOfQuantifiableVariable[] qVars = new ArrayOfQuantifiableVariable[l];
+	for (int i = 0; i < l; i++) {
+	    subs[i] = form.sub(i);
+	    if (isForm) {
+		subs[i] = replaceTerm(subs[i], divTerm, newVar);
+	    } else if (subs[i].sort() == Sort.FORMULA) {
+		subs[i] = replaceForm(subs[i], divForm, divTerm, newVar);
+	    }
+	    qVars[i] = subs[i].varsBoundHere(i);
+	}
+	return tf.createTerm(form.op(), subs, qVars, form.javaBlock());
+    }
+
+    private Term replaceTerm(Term term, Term divTerm, Term newVar) {
+	if (term.arity() == 0
+		|| term.op().name().toString().equals(
+			AbstractIntegerLDT.NUMBERS_NAME)) {
+	    return term;
+	} else if (term.equals(divTerm)) {
+	    return newVar;
+	} else {
+	    final int l = term.arity();
+	    final Term[] subs = new Term[l];
+	    final ArrayOfQuantifiableVariable[] qVars = new ArrayOfQuantifiableVariable[l];
+	    for (int i = 0; i < l; i++) {
+		subs[i] = replaceTerm(term.sub(i), divTerm, newVar);
+		qVars[i] = term.varsBoundHere(i);
+	    }
+	    return tf.createTerm(term.op(), subs, qVars, term.javaBlock());
+	}
+    }
+
+    private Term createAddConst(Term divTerm, Term newVar) {
+	final Term divident = divTerm.sub(0);
+	final Term divisor = divTerm.sub(1);
+	final Term multip = tf.createFunctionTerm(integerLDT.getMul(), newVar,
+		divisor);
+	return tf.createEqualityTerm(divident, multip);
+    }
+
+    public final StringBuffer pretranslate(Term term,
+	    Vector<QuantifiableVariable> quantifiedVars)
+	    throws SimplifyException {
+	// System.out.println("-Pretranslate");
+	// System.out.println(term);
+	// replace if-then-else terms
+	if (term.sort() == Sort.FORMULA && term.arity() > 0) {
+	    // This will be the if-condition of the found if-then-else term
+	    Term if_cond = null;
+	    while ((if_cond = findIfThenElse(term)) != null) {
+		Term term1 = replaceIfThenElse(term, if_cond, true);
+		Term term2 = replaceIfThenElse(term, if_cond, false);
+		term = tf.createJunctorTerm(Op.AND, tf.createJunctorTerm(
+			Op.IMP, if_cond, term1), tf.createJunctorTerm(Op.IMP,
+			tf.createJunctorTerm(Op.NOT, if_cond), term2));
+	    }
+	    Term divForm = null;
+	    Term divTerm = null;
+	    Term newVar = null;
+	    Term addConst = null;
+	    // System.out.println("---Term\n" + term);
+	    while ((divForm = findDivIForm(term)) != null) {
+		// System.out.println("\n");
+		// System.out.println("---DivForm\n" + divForm);
+		divTerm = findDivITerm(divForm);
+		// System.out.println("---divTerm\n" + divTerm);
+		newVar = tf.createVariableTerm(new LogicVariable(new Name(
+			getUniqueVariableName(divTerm.sort()).toString()),
+			divTerm.sort()));
+		// System.out.println("---newVar\n" + newVar);
+		addConst = createAddConst(divTerm, newVar);
+		// System.out.println("---AddConst\n" + addConst);
+		term = tf.createJunctorTerm(Op.AND, addConst, replaceForm(term,
+			divForm, divTerm, newVar));
+		// System.out.println("---ReplaceTerm\n" + term);
+	    }
+	}
+	return translate(term, quantifiedVars);
+    }
+
     /**
      * Translates the given term into "Simplify" input syntax and adds the
      * resulting string to the StringBuffer sb.
@@ -356,20 +507,6 @@ public class SimplifyTranslation {
 	    Vector<QuantifiableVariable> quantifiedVars)
 	    throws SimplifyException {
 	Operator op = term.op();
-	
-	//replace if-then-else terms
-	if(term.sort()==Sort.FORMULA && term.arity()>0 && term.sub(0).sort()!=Sort.FORMULA){
-	    Term if_cond=null; //This will be the if-condition of the found if-then-else term
-	    TermFactory tf= TermFactory.DEFAULT;
-	    while((if_cond=findIfThenElse(term))!=null){
-		Term term1 = replaceIfThenElse(term,if_cond,true);
-		Term term2 = replaceIfThenElse(term,if_cond,false);
-		term= tf.createJunctorTerm(Op.AND, 
-		    	tf.createJunctorTerm(Op.IMP, if_cond, term1), 
-		    	tf.createJunctorTerm(Op.IMP, tf.createJunctorTerm(Op.NOT, if_cond), term2));
-	    }
-	}
-	
 	if (op == Op.NOT) {
 	    return (translateSimpleTerm(term, NOT, quantifiedVars));
 	} else if (op == Op.AND) {
@@ -492,15 +629,32 @@ public class SimplifyTranslation {
 			.toString(), quantifiedVars));
 	    }
 	} else if ((op instanceof Modality) || (op instanceof IUpdateOperator)
-		/* ||(op instanceof IfThenElse)*/) {
+	/* ||(op instanceof IfThenElse) */) {
 	    return (uninterpretedTerm(term, true));
-	}if((op instanceof IfThenElse) && term.sort()!=Sort.FORMULA){
-	    throw new RuntimeException("The if-then-else term should have been replaced at this place.\n"+term.toString());
-	}  else {
+	}
+	if ((op instanceof IfThenElse)) {
+	    if (term.sort() != Sort.FORMULA) {
+		throw new RuntimeException(
+			"The if-then-else term should have been replaced at this place.\n"
+				+ term.toString());
+	    } else {
+		return translateIfThenElse(term, quantifiedVars);
+	    }
+	} else {
 	    return (translateUnknown(term));
 	}
     }
 
+    private final StringBuffer translateIfThenElse(Term term,
+	    Vector<QuantifiableVariable> quantifiedVars)
+	    throws SimplifyException {
+	Term cond = term.sub(0);
+	term = tf.createJunctorTerm(Op.AND, tf.createJunctorTerm(Op.IMP, cond,
+		term.sub(1)), tf.createJunctorTerm(Op.IMP, tf
+		.createJunctorTerm(Op.NOT, cond), term.sub(2)));
+	return translate(term, quantifiedVars);
+    }
+
     /**
      * Adds a predicate to the internal set and adds a line to declare the
      * predicate to the declarator stringbuffer.
@@ -617,7 +771,7 @@ public class SimplifyTranslation {
 	    boolean lightWeight) throws SimplifyException {
 	StringBuffer hb = new StringBuffer();
 	if (constraintSet.used(cf)) {
-	    
+
 	    SyntacticalReplaceVisitor srVisitor = new SyntacticalReplaceVisitor(
 		    constraintSet.getChosenConstraint());
 	    cf.formula().execPostOrder(srVisitor);
@@ -627,7 +781,7 @@ public class SimplifyTranslation {
 		    && !(op instanceof IUpdateOperator)
 		    && !(op instanceof IfThenElse) && op != Op.ALL
 		    && op != Op.EX) {
-		hb.append(translate(t, new Vector<QuantifiableVariable>()));
+		hb.append(pretranslate(t, new Vector<QuantifiableVariable>()));
 	    }
 	}
 	return hb;
diff --git a/system/de/uka/ilkd/key/unittest/testing/DataStorage.java b/system/de/uka/ilkd/key/unittest/testing/DataStorage.java
new file mode 100644
index 0000000..8fff11a
--- /dev/null
+++ b/system/de/uka/ilkd/key/unittest/testing/DataStorage.java
@@ -0,0 +1,147 @@
+// This file is part of KeY - Integrated Deductive Software Design
+// Copyright (C) 2001-2009 Universitaet Karlsruhe, Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General Public License. 
+// See LICENSE.TXT for details.
+package de.uka.ilkd.key.unittest.testing;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+
+import de.uka.ilkd.key.java.Expression;
+import de.uka.ilkd.key.java.Statement;
+import de.uka.ilkd.key.logic.Term;
+import de.uka.ilkd.key.logic.op.ProgramVariable;
+import de.uka.ilkd.key.logic.op.SetOfProgramMethod;
+import de.uka.ilkd.key.logic.op.SetOfProgramVariable;
+import de.uka.ilkd.key.unittest.ModelGenerator;
+import de.uka.ilkd.key.unittest.TestGenerator;
+import de.uka.ilkd.key.visualization.ExecutionTraceModel;
+
+/**
+ * This class stores certain values during the test case generation of KeY. It
+ * is needed only for the KeY junittests, namely the classes TestHelper and
+ * UniTestBuilder
+ * 
+ * @author mbender
+ * 
+ */
+public class DataStorage {
+
+    private SetOfProgramMethod pms;
+
+    private final LinkedList<ExecutionTraceModel[]> allETM = new LinkedList<ExecutionTraceModel[]>();
+
+    private int nodeCount;
+
+    private Statement[] code;
+
+    private Term oracle;
+
+    private LinkedList<ModelGenerator> mgs;
+
+    private SetOfProgramVariable pvs;
+
+    private TestGenerator tg;
+
+    private ProgramVariable[] pvs2;
+
+    private final ArrayList<Expression[][]> testDat = new ArrayList<Expression[][]>();
+
+    public DataStorage() {
+
+    }
+
+    public SetOfProgramMethod getPms() {
+	return pms;
+    }
+
+    public void setPms(SetOfProgramMethod pms) {
+	this.pms = pms;
+    }
+
+    public void addETM(ExecutionTraceModel[] etm) {
+	allETM.add(etm);
+    }
+
+    public int nrOfETMs() {
+	return allETM.size();
+    }
+
+    public int getNodeCount() {
+	return nodeCount;
+    }
+
+    public void setNodeCount(int nodeCount) {
+	this.nodeCount = nodeCount;
+    }
+
+    public Statement[] getCode() {
+	return code;
+    }
+
+    public void setCode(Statement[] code) {
+	this.code = code;
+    }
+
+    public Term getOracle() {
+	return oracle;
+    }
+
+    public void setOracle(Term oracle) {
+	this.oracle = oracle;
+    }
+
+    public LinkedList<ModelGenerator> getMgs() {
+	return mgs;
+    }
+
+    public void setMgs(LinkedList<ModelGenerator> mgs) {
+	this.mgs = mgs;
+    }
+
+    public SetOfProgramVariable getPvs() {
+	return pvs;
+    }
+
+    public void setPvs(SetOfProgramVariable pvs) {
+	this.pvs = pvs;
+    }
+
+    public TestGenerator getTg() {
+	return tg;
+    }
+
+    public void setTg(TestGenerator tg) {
+	this.tg = tg;
+    }
+
+    public ProgramVariable[] getPvs2() {
+	return pvs2;
+    }
+
+    public void setPvs2(ProgramVariable[] pvs2) {
+	this.pvs2 = pvs2;
+    }
+
+    public void addTestDat(Expression[][] tdat) {
+	testDat.add(tdat);
+    }
+
+    public int getNrOfTestDat() {
+	return testDat.size();
+    }
+
+    public int calcSum() {
+	int sum = 0;
+	for (Expression[][] currAA : testDat) {
+	    for (Expression[] currA : currAA) {
+		int currInt = Integer.parseInt(currA[0].toString());
+		sum += ((currInt < 0) ? -currInt : currInt);
+	    }
+	}
+	return sum;
+    }
+}
diff --git a/system/de/uka/ilkd/key/unittest/testing/TestHelper.java b/system/de/uka/ilkd/key/unittest/testing/TestHelper.java
new file mode 100644
index 0000000..0b1f319
--- /dev/null
+++ b/system/de/uka/ilkd/key/unittest/testing/TestHelper.java
@@ -0,0 +1,197 @@
+// This file is part of KeY - Integrated Deductive Software Design
+// Copyright (C) 2001-2009 Universitaet Karlsruhe, Germany
+//                         Universitaet Koblenz-Landau, Germany
+//                         Chalmers University of Technology, Sweden
+//
+// The KeY system is protected by the GNU General Public License. 
+// See LICENSE.TXT for details.
+
+package de.uka.ilkd.key.unittest.testing;
+
+import java.io.File;
+import java.util.Iterator;
+
+import de.uka.ilkd.key.gui.AutoModeListener;
+import de.uka.ilkd.key.gui.KeYMediator;
+import de.uka.ilkd.key.gui.ProverTaskListener;
+import de.uka.ilkd.key.gui.SimpleStarter;
+import de.uka.ilkd.key.gui.TaskFinishedInfo;
+import de.uka.ilkd.key.gui.configuration.ProofSettings;
+import de.uka.ilkd.key.logic.op.IteratorOfProgramMethod;
+import de.uka.ilkd.key.logic.op.SetOfProgramMethod;
+import de.uka.ilkd.key.proof.ProblemLoader;
+import de.uka.ilkd.key.proof.Proof;
+import de.uka.ilkd.key.proof.ProofEvent;
+import de.uka.ilkd.key.proof.init.JavaProfile;
+import de.uka.ilkd.key.proof.init.JavaTestGenerationProfile;
+import de.uka.ilkd.key.proof.init.Profile;
+import de.uka.ilkd.key.unittest.ModelGenerator;
+import de.uka.ilkd.key.unittest.UnitTestBuilder;
+import de.uka.ilkd.key.unittest.simplify.OldSimplifyModelGenerator;
+
+/**
+ * This class "wraps" a proof in KeY. It is needed only for the KeY junittests,
+ * namely the class TestTestGenerator
+ * 
+ * @author mbender
+ */
+public class TestHelper {
+
+    private final String file;
+
+    private final SimpleStarter main;
+
+    private final KeYMediator medi;
+
+    private final Proof proof;
+
+    private final UnitTestBuilder utb;
+
+    private final DataStorage data;
+
+    private final SetOfProgramMethod pms;
+
+    final Object semaphorLoad = new Object();
+
+    final Object semaphorProof = new Object();
+
+    final static String PATH = System.getProperty("key.home") + File.separator
+	    + "examples" + File.separator + "_testcase" + File.separator
+	    + "testgen" + File.separator;
+
+    public TestHelper(String file, boolean prove) {
+	// Init
+	this.file = PATH + file;
+	main = new SimpleStarter(this.file, createPTListener());
+	medi = new KeYMediator(main);
+	main.setKeYMediator(medi);
+	// Loading
+	medi.addAutoModeListener(createAMListener());
+	final Profile profil = (prove ? new JavaTestGenerationProfile(main)
+		: new JavaProfile(main));
+	ProofSettings.DEFAULT_SETTINGS.setProfile(profil);
+	synchronized (semaphorLoad) {
+	    try {
+		main.loadCommandLineFile();
+		semaphorLoad.wait();
+	    } catch (InterruptedException e1) {
+		e1.printStackTrace();
+	    }
+	}
+	proof = medi.getProof();
+	// Proving
+	if (prove) {
+	    medi.setSimplifier(ProofSettings.DEFAULT_SETTINGS
+		    .getSimultaneousUpdateSimplifierSettings().getSimplifier());
+	    medi.setMaxAutomaticSteps(1000);
+	    medi.getProof().setActiveStrategy(
+		    profil.getDefaultStrategyFactory().create(proof, null));
+	    synchronized (semaphorProof) {
+		try {
+		    medi.startAutoMode();
+		    semaphorProof.wait();
+		} catch (InterruptedException e1) {
+		    e1.printStackTrace();
+		}
+	    }
+	}
+	// Testing
+	utb = new UnitTestBuilder(medi.getServices(), proof, true);
+	utb.createTestForProof(proof);
+	data = utb.getDS();
+	pms = data.getPms();
+    }
+
+    public Proof getProof() {
+	return proof;
+    }
+
+    public int getNrofOG() {
+	return proof.openEnabledGoals().size();
+    }
+
+    public String getFName() {
+	return file;
+    }
+
+    public int nrOfMeth() {
+	return pms.size();
+    }
+
+    public String methNames() {
+	String result = "";
+	IteratorOfProgramMethod iter = pms.iterator();
+	while (iter.hasNext()) {
+	    result = result.concat(iter.next().toString());
+	}
+	return result;
+    }
+
+    public int getNrOfNodes() {
+	return data.getNodeCount();
+    }
+
+    public int getNrOfStatements() {
+	return data.getCode().length;
+    }
+
+    public int getNrOfMGS() {
+	return data.getMgs().size();
+    }
+
+    public int getNrOfPV() {
+	return data.getPvs().size();
+    }
+
+    public boolean isOracleNnull() {
+	return data.getOracle() != null;
+    }
+
+    public int getNrOfPV2() {
+	return data.getPvs2().length;
+    }
+
+    public int getNrOfTestDat() {
+	return data.getNrOfTestDat();
+    }
+
+    public int calcSum() {
+	return data.calcSum();
+    }
+
+    private ProverTaskListener createPTListener() {
+	return new ProverTaskListener() {
+
+	    public void taskStarted(String message, int size) {
+	    }
+
+	    public void taskProgress(int position) {
+	    }
+
+	    public void taskFinished(TaskFinishedInfo info) {
+		if (info.getSource() instanceof ProblemLoader) {
+		    synchronized (semaphorLoad) {
+			semaphorLoad.notifyAll();
+		    }
+		}
+
+	    }
+	};
+    }
+
+    private AutoModeListener createAMListener() {
+	return new AutoModeListener() {
+
+	    public void autoModeStopped(ProofEvent e) {
+		if (e.getSource() != null) {
+		    synchronized (semaphorProof) {
+			semaphorProof.notifyAll();
+		    }
+		}
+	    }
+
+	    public void autoModeStarted(ProofEvent e) {
+	    }
+	};
+    }
+}
